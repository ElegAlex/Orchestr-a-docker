import React, { useState, useEffect } from 'react';
import { useSelector } from 'react-redux';
import { RootState } from '../../store';
import {
  Dialog,
  DialogTitle,
  DialogContent,
  DialogActions,
  Button,
  TextField,
  FormControl,
  InputLabel,
  Select,
  MenuItem,
  Grid,
  Chip,
  Box,
  Typography,
  Autocomplete,
  Tabs,
  Tab,
  List,
  ListItem,
  ListItemText,
  ListItemSecondaryAction,
  IconButton,
  Accordion,
  AccordionSummary,
  AccordionDetails,
  FormControlLabel,
  Switch,
  Divider,
  Alert,
} from '@mui/material';
import {
  Close as CloseIcon,
  Add as AddIcon,
  Delete as DeleteIcon,
  ExpandMore as ExpandMoreIcon,
  AccessTime as TimeIcon,
  Link as LinkIcon,
  Flag as FlagIcon,
  Business as BusinessIcon,
} from '@mui/icons-material';
import { Task, TaskType, TaskStatus, Priority, User, Project, RequiredSkill, Epic, Milestone } from '../../types';
import { taskService } from '../../services/task.service';
import { projectService } from '../../services/project.service';
import { userService } from '../../services/user.service';
import { epicService } from '../../services/epic.service';
import { milestoneService } from '../../services/milestone.service';
import { TimeTracker } from './TimeTracker';
import { TaskComments } from './TaskComments';
import { TaskAttachments } from './TaskAttachments';
import { SkillSelector } from '../skills/SkillSelector';

interface TaskModalProps {
  open: boolean;
  onClose: () => void;
  task?: Task | null;
  projectId?: string;
  dueDate?: Date; // Date d'échéance depuis le planning
  onSave: (task: Task) => void;
  onDelete?: (taskId: string) => void; // Callback pour supprimer une tâche
}

interface TabPanelProps {
  children?: React.ReactNode;
  index: number;
  value: number;
}

const TabPanel: React.FC<TabPanelProps> = ({ children, value, index }) => (
  <div hidden={value !== index} style={{ paddingTop: 16 }}>
    {value === index && children}
  </div>
);

export const TaskModal: React.FC<TaskModalProps> = ({
  open,
  onClose,
  task,
  projectId,
  dueDate,
  onSave,
  onDelete,
}) => {
  const user = useSelector((state: RootState) => state.auth.user);
  const [activeTab, setActiveTab] = useState(0);
  const [loading, setLoading] = useState(false);
  const [projects, setProjects] = useState<Project[]>([]);
  const [users, setUsers] = useState<User[]>([]);
  const [epics, setEpics] = useState<Epic[]>([]);
  const [milestones, setMilestones] = useState<Milestone[]>([]);
  
  // Form state - Version simplifiée
  const [formData, setFormData] = useState({
    title: '',
    description: '',
    type: 'TASK' as TaskType,
    status: 'TODO' as TaskStatus,
    priority: 'P2' as Priority,
    projectId: projectId || '',
    responsible: [] as string[],    // R - Responsable(s)
    accountable: [] as string[],    // A - Autorité
    consulted: [] as string[],      // C - Consulté(s)
    informed: [] as string[],       // I - Informé(s)
    epicId: '',
    milestoneId: '',
    parentTaskId: '',
    storyPoints: 0,
    estimatedHours: 0,
    businessValue: 5,
    riskLevel: 'medium' as 'low' | 'medium' | 'high' | 'critical',
    startDate: '',
    dueDate: dueDate ? dueDate.toISOString().split('T')[0] : '',
    requiredSkills: [] as RequiredSkill[],
  });

  // Nouveau champ pour le temps déclaré
  const [timeSpent, setTimeSpent] = useState('');
  const [errors, setErrors] = useState<Record<string, string>>({});

  useEffect(() => {
    if (open) {
      loadProjects();
      loadUsers();
      if (formData.projectId) {
        loadEpicsAndMilestones(formData.projectId);
      }
      if (task) {
        populateForm(task);
      } else {
        resetForm();
      }
    }
  }, [open, task, projectId, dueDate]);

  // Charger epics et milestones quand le projet change
  useEffect(() => {
    if (formData.projectId && open) {
      loadEpicsAndMilestones(formData.projectId);
    }
  }, [formData.projectId, open]);

  const loadProjects = async () => {
    try {
      const projectsData = await projectService.getAllProjects();
      
      setProjects(projectsData);
    } catch (error) {
      console.error('Erreur lors du chargement des projets:', error);
      setProjects([]);
    }
  };

  const loadUsers = async () => {
    try {
      // Charger les vrais utilisateurs depuis le service
      const allUsers = await userService.getAllUsers();
      setUsers(allUsers);
    } catch (error) {
      console.error('Erreur lors du chargement des utilisateurs:', error);
      setUsers([]);
    }
  };

  const loadEpicsAndMilestones = async (projectId: string) => {
    try {
      const [epicsData, milestonesData] = await Promise.all([
        epicService.getProjectEpics(projectId),
        milestoneService.getProjectMilestones(projectId)
      ]);
      setEpics(epicsData);
      setMilestones(milestonesData);
    } catch (error) {
      console.error('Erreur lors du chargement des epics et milestones:', error);
      setEpics([]);
      setMilestones([]);
    }
  };

  const populateForm = (taskData: Task) => {
    setFormData({
      title: taskData.title,
      description: taskData.description,
      type: taskData.type,
      status: taskData.status,
      priority: taskData.priority,
      projectId: taskData.projectId,
      responsible: taskData.responsible || [],
      accountable: taskData.accountable || [],
      consulted: taskData.consulted || [],
      informed: taskData.informed || [],
      epicId: taskData.epicId || '',
      milestoneId: taskData.milestoneId || '',
      parentTaskId: taskData.parentTaskId || '',
      storyPoints: taskData.storyPoints || 0,
      estimatedHours: taskData.estimatedHours || 0,
      businessValue: taskData.businessValue || 5,
      riskLevel: (taskData.riskLevel || 'medium') as 'low' | 'medium' | 'high' | 'critical',
      startDate: taskData.startDate ? taskData.startDate.toISOString().split('T')[0] : '',
      dueDate: taskData.dueDate ? taskData.dueDate.toISOString().split('T')[0] : '',
      requiredSkills: taskData.requiredSkills || [],
    });
  };

  const resetForm = () => {
    setFormData({
      title: '',
      description: '',
      type: 'TASK' as TaskType,
      status: 'TODO' as TaskStatus,
      priority: 'P2' as Priority,
      projectId: projectId || '',
      responsible: [] as string[],
      accountable: [] as string[],
      consulted: [] as string[],
      informed: [] as string[],
      epicId: '',
      milestoneId: '',
      parentTaskId: '',
      sprintId: '',
      storyPoints: 0,
      estimatedHours: 0,
      businessValue: 5,
      riskLevel: 'medium' as 'low' | 'medium' | 'high' | 'critical',
      technicalDebt: false,
      labels: [] as string[],
      definitionOfDone: [] as string[],
      startDate: '',
      dueDate: dueDate ? dueDate.toISOString().split('T')[0] : '',
      requiredSkills: [] as RequiredSkill[],
    });
    setErrors({});
    setActiveTab(0);
  };

  const validateForm = () => {
    const newErrors: Record<string, string> = {};

    if (!formData.title.trim()) {
      newErrors.title = 'Le titre est obligatoire';
    }
    if (!formData.description.trim()) {
      newErrors.description = 'La description est obligatoire';
    }
    // Le projet n'est plus obligatoire (peut être "Non affecté")
    // if (!formData.projectId) {
    //   newErrors.projectId = 'Le projet est obligatoire';
    // }
    // Plus de champs obligatoires pour RACI - tous optionnels

    // Validation des dates
    if (formData.startDate && formData.dueDate) {
      const startDate = new Date(formData.startDate);
      const dueDate = new Date(formData.dueDate);
      if (startDate > dueDate) {
        newErrors.startDate = 'La date de début doit être antérieure à la date d\'échéance';
      }
    }

    setErrors(newErrors);
    return Object.keys(newErrors).length === 0;
  };

  const handleSave = async () => {
    if (!validateForm()) {
      return;
    }

    setLoading(true);
    try {
      const taskData: any = {
        ...formData,
        dependencies: [],
        attachments: [],
        comments: [],
        customFields: {},
        isBlocked: false,
        timeSpent: 0,
        loggedHours: 0,
        remainingHours: formData.estimatedHours,
      };
      
      // Ajouter startDate si elle existe
      if (formData.startDate && formData.startDate.trim() !== '') {
        const startDateObj = new Date(formData.startDate);
        taskData.startDate = startDateObj;
      }
      
      // Ajouter dueDate si elle existe
      if (formData.dueDate && formData.dueDate.trim() !== '') {
        const dueDateObj = new Date(formData.dueDate);
        taskData.dueDate = dueDateObj;
        
        // Si pas de startDate définie, utiliser la même date que dueDate à 9h
        if (!taskData.startDate) {
          taskData.startDate = new Date(dueDateObj.getFullYear(), dueDateObj.getMonth(), dueDateObj.getDate(), 9, 0);
        }
      }
      
      // Nettoyer tous les champs undefined
      Object.keys(taskData).forEach(key => {
        if (taskData[key] === undefined) {
          delete taskData[key];
        }
      });

      let savedTask: Task;
      if (task) {
        savedTask = await taskService.updateTask(task.id, taskData);
      } else {
        savedTask = await taskService.createTask({
          ...taskData,
          createdBy: user?.id || '',
        });
      }

      onSave(savedTask);

      
      onClose();
    } catch (error) {
      console.error('Erreur lors de la sauvegarde de la tâche:', error);
      
      let errorMessage = 'Erreur inconnue';
      if (error instanceof Error) {
        errorMessage = error.message;
      } else if (typeof error === 'string') {
        errorMessage = error;
      }
      
      alert(`Erreur lors de la sauvegarde: ${errorMessage}`);
    } finally {
      setLoading(false);
    }
  };

  const handleDelete = async () => {
    if (!task || !task.id || !onDelete) return;
    
    const confirmDelete = window.confirm(
      `Êtes-vous sûr de vouloir supprimer définitivement la tâche "${task.title}" ?\n\nCette action est irréversible.`
    );
    
    if (!confirmDelete) return;
    
    try {
      setLoading(true);
      await onDelete(task.id);
      onClose();
    } catch (error) {
      console.error('Erreur lors de la suppression de la tâche:', error);
      alert('Erreur lors de la suppression de la tâche');
    } finally {
      setLoading(false);
    }
  };

  const addLabel = () => {
    if (newLabel.trim() && !formData.labels.includes(newLabel.trim())) {
      setFormData({
        ...formData,
        labels: [...formData.labels, newLabel.trim()]
      });
      setNewLabel('');
    }
  };

  const removeLabel = (labelToRemove: string) => {
    setFormData({
      ...formData,
      labels: formData.labels.filter(label => label !== labelToRemove)
    });
  };

  const addDoDItem = () => {
    if (newDoDItem.trim()) {
      setFormData({
        ...formData,
        definitionOfDone: [...formData.definitionOfDone, newDoDItem.trim()]
      });
      setNewDoDItem('');
    }
  };

  const removeDoDItem = (index: number) => {
    setFormData({
      ...formData,
      definitionOfDone: formData.definitionOfDone.filter((_, i) => i !== index)
    });
  };

  const getTypeIcon = (type: TaskType) => {
    const icons = {
      EPIC: '🏔️',
      STORY: '📝',
      TASK: '✅',
      BUG: '🐛',
      SPIKE: '🔬',
    };
    return icons[type];
  };

  const getPriorityColor = (priority: Priority) => {
    const colors = {
      P0: '#f44336',
      P1: '#ff9800',
      P2: '#2196f3',
      P3: '#9e9e9e',
    };
    return colors[priority];
  };

  return (
    <Dialog
      open={open}
      onClose={onClose}
      maxWidth="md"
      fullWidth
      PaperProps={{
        sx: { height: '90vh' }
      }}
    >
      <DialogTitle sx={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between' }}>
        <Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
          <Typography variant="h6">
            {task ? 'Modifier la tâche' : 'Nouvelle tâche'}
          </Typography>
          {formData.type && (
            <Chip
              label={`${getTypeIcon(formData.type)} ${formData.type}`}
              size="small"
              color="primary"
            />
          )}
        </Box>
        <IconButton onClick={onClose}>
          <CloseIcon />
        </IconButton>
      </DialogTitle>

      <DialogContent sx={{ p: 0 }}>
        <Tabs
          value={activeTab}
          onChange={(_, newValue) => setActiveTab(newValue)}
          sx={{ borderBottom: 1, borderColor: 'divider', px: 3 }}
        >
          <Tab label="Essentiel" />
          <Tab label="Planning & Équipe" />
          {task && <Tab label="Commentaires" />}
          {task && <Tab label="Fichiers" />}
        </Tabs>

        <Box sx={{ px: 3, py: 2, height: 'calc(90vh - 200px)', overflowY: 'auto' }}>
          {/* Onglet Essentiel - Tout l'essentiel en un seul onglet */}
          <TabPanel value={activeTab} index={0}>
            <Box sx={{ display: "flex", gap: 3, flexWrap: "wrap" }}>
              <Box sx={{ flexGrow: 1, minWidth: 200 }}>
                <TextField
                  fullWidth
                  label="Titre"
                  value={formData.title}
                  onChange={(e) => setFormData({ ...formData, title: e.target.value })}
                  error={!!errors.title}
                  helperText={errors.title}
                  required
                />
              </Box>

              <Box sx={{ flexGrow: 1, minWidth: 200 }}>
                <TextField
                  fullWidth
                  multiline
                  rows={4}
                  label="Description"
                  value={formData.description}
                  onChange={(e) => setFormData({ ...formData, description: e.target.value })}
                  error={!!errors.description}
                  helperText={errors.description}
                  required
                />
              </Box>

              <Box sx={{ flexGrow: 1, minWidth: 200 }}>
                <FormControl fullWidth required>
                  <InputLabel>Type</InputLabel>
                  <Select
                    value={formData.type}
                    label="Type"
                    onChange={(e) => setFormData({ ...formData, type: e.target.value as TaskType })}
                  >
                    {(['EPIC', 'STORY', 'TASK', 'BUG', 'SPIKE'] as TaskType[]).map((type) => (
                      <MenuItem key={type} value={type}>
                        {getTypeIcon(type)} {type}
                      </MenuItem>
                    ))}
                  </Select>
                </FormControl>
              </Box>

              <Box sx={{ flexGrow: 1, minWidth: 200 }}>
                <FormControl fullWidth required>
                  <InputLabel>Priorité</InputLabel>
                  <Select
                    value={formData.priority}
                    label="Priorité"
                    onChange={(e) => setFormData({ ...formData, priority: e.target.value as Priority })}
                  >
                    {(['P0', 'P1', 'P2', 'P3'] as Priority[]).map((priority) => (
                      <MenuItem key={priority} value={priority}>
                        <Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
                          <Box
                            sx={{
                              width: 12,
                              height: 12,
                              borderRadius: '50%',
                              bgcolor: getPriorityColor(priority)
                            }}
                          />
                          {priority} - {priority === 'P0' ? 'Critique' : priority === 'P1' ? 'Élevé' : priority === 'P2' ? 'Normal' : 'Faible'}
                        </Box>
                      </MenuItem>
                    ))}
                  </Select>
                </FormControl>
              </Box>

              <Box sx={{ flexGrow: 1, minWidth: 200 }}>
                <FormControl fullWidth>
                  <InputLabel>Projet</InputLabel>
                  <Select
                    value={formData.projectId || 'unassigned'}
                    label="Projet"
                    onChange={(e) => setFormData({ ...formData, projectId: e.target.value === 'unassigned' ? '' : e.target.value })}
                    error={!!errors.projectId}
                  >
                    <MenuItem value="unassigned">
                      <Box sx={{ display: 'flex', alignItems: 'center', gap: 1, fontStyle: 'italic', color: 'text.secondary' }}>
                        <BusinessIcon fontSize="small" />
                        Non affecté (Admin, Formation, etc.)
                      </Box>
                    </MenuItem>
                    {projects.map((project) => (
                      <MenuItem key={project.id} value={project.id}>
                        {project.name} ({project.code})
                      </MenuItem>
                    ))}
                  </Select>
                </FormControl>
              </Box>

              <Box sx={{ flexGrow: 1, minWidth: 200 }}>
                <FormControl fullWidth>
                  <InputLabel>Statut</InputLabel>
                  <Select
                    value={formData.status}
                    label="Statut"
                    onChange={(e) => setFormData({ ...formData, status: e.target.value as TaskStatus })}
                  >
                    {(['BACKLOG', 'TODO', 'IN_PROGRESS', 'REVIEW', 'TESTING', 'DONE', 'BLOCKED'] as TaskStatus[]).map((status) => (
                      <MenuItem key={status} value={status}>
                        {status}
                      </MenuItem>
                    ))}
                  </Select>
                </FormControl>
              </Box>

              {/* Epic et Milestone */}
              <Box sx={{ flexGrow: 1, minWidth: 200 }}>
                <FormControl fullWidth>
                  <InputLabel>Epic (optionnel)</InputLabel>
                  <Select
                    value={formData.epicId || ''}
                    label="Epic (optionnel)"
                    onChange={(e) => setFormData({ ...formData, epicId: e.target.value })}
                  >
                    <MenuItem value="">
                      <em>Aucun Epic</em>
                    </MenuItem>
                    {epics.map((epic) => (
                      <MenuItem key={epic.id} value={epic.id}>
                        {epic.code} - {epic.title}
                      </MenuItem>
                    ))}
                  </Select>
                </FormControl>
              </Box>

              <Box sx={{ flexGrow: 1, minWidth: 200 }}>
                <FormControl fullWidth>
                  <InputLabel>Jalon (optionnel)</InputLabel>
                  <Select
                    value={formData.milestoneId || ''}
                    label="Jalon (optionnel)"
                    onChange={(e) => setFormData({ ...formData, milestoneId: e.target.value })}
                  >
                    <MenuItem value="">
                      <em>Aucun Jalon</em>
                    </MenuItem>
                    {milestones.map((milestone) => (
                      <MenuItem key={milestone.id} value={milestone.id}>
                        {milestone.code} - {milestone.name}
                      </MenuItem>
                    ))}
                  </Select>
                </FormControl>
              </Box>

              {/* Labels */}
              <Box sx={{ flexGrow: 1, minWidth: 200 }}>
                <Box>
                  <Typography variant="subtitle2" gutterBottom>
                    Labels
                  </Typography>
                  <Box sx={{ display: 'flex', flexWrap: 'wrap', gap: 1, mb: 2 }}>
                    {formData.labels.map((label) => (
                      <Chip
                        key={label}
                        label={label}
                        size="small"
                        onDelete={() => removeLabel(label)}
                        deleteIcon={<DeleteIcon />}
                      />
                    ))}
                  </Box>
                  <Box sx={{ display: 'flex', gap: 1 }}>
                    <TextField
                      size="small"
                      placeholder="Nouveau label"
                      value={newLabel}
                      onChange={(e) => setNewLabel(e.target.value)}
                      onKeyPress={(e) => e.key === 'Enter' && addLabel()}
                    />
                    <Button
                      variant="outlined"
                      size="small"
                      startIcon={<AddIcon />}
                      onClick={addLabel}
                    >
                      Ajouter
                    </Button>
                  </Box>
                </Box>
              </Box>

              {/* Compétences requises */}
              <Box sx={{ flexGrow: 1, minWidth: 200 }}>
                <SkillSelector
                  value={formData.requiredSkills}
                  onChange={(skills) => setFormData({ ...formData, requiredSkills: skills })}
                  availablePeople={users.map(user => ({
                    id: user.id,
                    name: user.displayName,
                    skills: user.skills?.map(skill => ({
                      name: typeof skill === 'string' ? skill : skill.name,
                      level: typeof skill === 'string' ? (Math.floor(Math.random() * 3) + 1 as 1 | 2 | 3) : skill.level
                    })) || []
                  }))}
                />
              </Box>
            </Box>
          </TabPanel>

          {/* Onglet Détails */}
          <TabPanel value={activeTab} index={1}>
            <Box sx={{ display: "flex", gap: 3, flexWrap: "wrap" }}>
              {/* Structure RACI */}
              <Box sx={{ flexGrow: 1, minWidth: 200 }}>
                <Typography variant="h6" gutterBottom color="primary">
                  🏆 Matrice RACI - Attribution des responsabilités
                </Typography>
                <Typography variant="body2" color="text.secondary" sx={{ mb: 3 }}>
                  Tous les champs sont optionnels. Définissez les rôles selon vos besoins.
                </Typography>
              </Box>

              <Box sx={{ flexGrow: 1, minWidth: 200 }}>
                <Autocomplete
                  multiple
                  options={users}
                  getOptionLabel={(option) => option.displayName}
                  value={users.filter(u => formData.responsible.includes(u.id))}
                  onChange={(_, values) => setFormData({ ...formData, responsible: values.map(v => v.id) })}
                  renderInput={(params) => (
                    <TextField 
                      {...params} 
                      label="🎯 Responsable (R)" 
                      helperText="Qui exécute la tâche ?" 
                    />
                  )}
                  renderTags={(value, getTagProps) =>
                    value.map((option, index) => (
                      <Chip 
                        variant="outlined" 
                        color="primary"
                        label={option.displayName} 
                        {...getTagProps({ index })} 
                      />
                    ))
                  }
                />
              </Box>

              <Box sx={{ flexGrow: 1, minWidth: 200 }}>
                <Autocomplete
                  multiple
                  options={users}
                  getOptionLabel={(option) => option.displayName}
                  value={users.filter(u => formData.accountable.includes(u.id))}
                  onChange={(_, values) => setFormData({ ...formData, accountable: values.map(v => v.id) })}
                  renderInput={(params) => (
                    <TextField 
                      {...params} 
                      label="⚖️ Autorité (A)" 
                      helperText="Qui prend la décision finale ?" 
                    />
                  )}
                  renderTags={(value, getTagProps) =>
                    value.map((option, index) => (
                      <Chip 
                        variant="outlined" 
                        color="error"
                        label={option.displayName} 
                        {...getTagProps({ index })} 
                      />
                    ))
                  }
                />
              </Box>

              <Box sx={{ flexGrow: 1, minWidth: 200 }}>
                <Autocomplete
                  multiple
                  options={users}
                  getOptionLabel={(option) => option.displayName}
                  value={users.filter(u => formData.consulted.includes(u.id))}
                  onChange={(_, values) => setFormData({ ...formData, consulted: values.map(v => v.id) })}
                  renderInput={(params) => (
                    <TextField 
                      {...params} 
                      label="💬 Consulté (C)" 
                      helperText="Qui fournit son expertise ?" 
                    />
                  )}
                  renderTags={(value, getTagProps) =>
                    value.map((option, index) => (
                      <Chip 
                        variant="outlined" 
                        color="warning"
                        label={option.displayName} 
                        {...getTagProps({ index })} 
                      />
                    ))
                  }
                />
              </Box>

              <Box sx={{ flexGrow: 1, minWidth: 200 }}>
                <Autocomplete
                  multiple
                  options={users}
                  getOptionLabel={(option) => option.displayName}
                  value={users.filter(u => formData.informed.includes(u.id))}
                  onChange={(_, values) => setFormData({ ...formData, informed: values.map(v => v.id) })}
                  renderInput={(params) => (
                    <TextField 
                      {...params} 
                      label="📢 Informé (I)" 
                      helperText="Qui doit être tenu au courant ?" 
                    />
                  )}
                  renderTags={(value, getTagProps) =>
                    value.map((option, index) => (
                      <Chip 
                        variant="outlined" 
                        color="info"
                        label={option.displayName} 
                        {...getTagProps({ index })} 
                      />
                    ))
                  }
                />
              </Box>

              <Box sx={{ flexGrow: 1, minWidth: 200 }}>
                <TextField
                  fullWidth
                  multiline
                  rows={3}
                  label="Critères d'acceptation"
                  value={formData.acceptanceCriteria}
                  onChange={(e) => setFormData({ ...formData, acceptanceCriteria: e.target.value })}
                  placeholder="Définir les critères qui déterminent quand cette tâche sera considérée comme terminée..."
                />
              </Box>

              {/* Definition of Done */}
              <Box sx={{ flexGrow: 1, minWidth: 200 }}>
                <Box>
                  <Typography variant="subtitle2" gutterBottom>
                    Définition du fini (DoD)
                  </Typography>
                  <List dense>
                    {formData.definitionOfDone.map((item, index) => (
                      <ListItem key={index}>
                        <ListItemText
                          primary={`${index + 1}. ${item}`}
                        />
                        <ListItemSecondaryAction>
                          <IconButton
                            edge="end"
                            size="small"
                            onClick={() => removeDoDItem(index)}
                          >
                            <DeleteIcon fontSize="small" />
                          </IconButton>
                        </ListItemSecondaryAction>
                      </ListItem>
                    ))}
                  </List>
                  <Box sx={{ display: 'flex', gap: 1, mt: 1 }}>
                    <TextField
                      fullWidth
                      size="small"
                      placeholder="Nouvel élément de la DoD"
                      value={newDoDItem}
                      onChange={(e) => setNewDoDItem(e.target.value)}
                      onKeyPress={(e) => e.key === 'Enter' && addDoDItem()}
                    />
                    <Button
                      variant="outlined"
                      size="small"
                      startIcon={<AddIcon />}
                      onClick={addDoDItem}
                    >
                      Ajouter
                    </Button>
                  </Box>
                </Box>
              </Box>
            </Box>
          </TabPanel>

          {/* Onglet Planning */}
          <TabPanel value={activeTab} index={2}>
            <Box sx={{ display: "flex", gap: 3, flexWrap: "wrap" }}>
              <Box sx={{ flexGrow: 1, minWidth: 200 }}>
                <TextField
                  fullWidth
                  type="number"
                  label="Story Points"
                  value={formData.storyPoints}
                  onChange={(e) => setFormData({ ...formData, storyPoints: parseInt(e.target.value) || 0 })}
                  InputProps={{
                    startAdornment: <FlagIcon sx={{ mr: 1, color: 'text.secondary' }} />,
                  }}
                />
              </Box>

              <Box sx={{ flexGrow: 1, minWidth: 200 }}>
                <TextField
                  fullWidth
                  type="number"
                  label="Estimation (heures)"
                  value={formData.estimatedHours}
                  onChange={(e) => setFormData({ ...formData, estimatedHours: parseFloat(e.target.value) || 0 })}
                  InputProps={{
                    startAdornment: <TimeIcon sx={{ mr: 1, color: 'text.secondary' }} />,
                  }}
                />
              </Box>

              <Box sx={{ flexGrow: 1, minWidth: 200 }}>
                <TextField
                  fullWidth
                  type="date"
                  label="Date de début"
                  value={formData.startDate}
                  onChange={(e) => setFormData({ ...formData, startDate: e.target.value })}
                  InputLabelProps={{
                    shrink: true,
                  }}
                  error={!!errors.startDate}
                  helperText={errors.startDate}
                />
              </Box>

              <Box sx={{ flexGrow: 1, minWidth: 200 }}>
                <TextField
                  fullWidth
                  type="date"
                  label="Date d'échéance"
                  value={formData.dueDate}
                  onChange={(e) => setFormData({ ...formData, dueDate: e.target.value })}
                  InputLabelProps={{
                    shrink: true,
                  }}
                  error={!!errors.dueDate}
                  helperText={errors.dueDate}
                />
              </Box>

              <Box sx={{ flexGrow: 1, minWidth: 200 }}>
                <TextField
                  fullWidth
                  type="number"
                  label="Valeur métier (1-10)"
                  value={formData.businessValue}
                  onChange={(e) => setFormData({ ...formData, businessValue: parseInt(e.target.value) || 5 })}
                  inputProps={{ min: 1, max: 10 }}
                  InputProps={{
                    startAdornment: <BusinessIcon sx={{ mr: 1, color: 'text.secondary' }} />,
                  }}
                />
              </Box>

              <Box sx={{ flexGrow: 1, minWidth: 200 }}>
                <FormControl fullWidth>
                  <InputLabel>Niveau de risque</InputLabel>
                  <Select
                    value={formData.riskLevel}
                    label="Niveau de risque"
                    onChange={(e) => setFormData({ ...formData, riskLevel: e.target.value as any })}
                  >
                    <MenuItem value="low">🟢 Faible</MenuItem>
                    <MenuItem value="medium">🟡 Moyen</MenuItem>
                    <MenuItem value="high">🟠 Élevé</MenuItem>
                    <MenuItem value="critical">🔴 Critique</MenuItem>
                  </Select>
                </FormControl>
              </Box>

              <Box sx={{ flexGrow: 1, minWidth: 200 }}>
                <FormControlLabel
                  control={
                    <Switch
                      checked={formData.technicalDebt}
                      onChange={(e) => setFormData({ ...formData, technicalDebt: e.target.checked })}
                    />
                  }
                  label="Dette technique"
                />
              </Box>
            </Box>
          </TabPanel>

          {/* Onglet Temps - seulement pour les tâches existantes */}
          {task && (
            <TabPanel value={activeTab} index={3}>
              <TimeTracker
                task={task}
                onTaskUpdate={(updatedTask) => {
                  onSave(updatedTask);
                }}
              />
            </TabPanel>
          )}

          {/* Onglet Qualité */}
          <TabPanel value={activeTab} index={task ? 4 : 3}>
            <Box sx={{ mb: 3 }}>
              <Alert severity="info">
                Cet onglet permettra de gérer les aspects qualité : tests, revues de code, 
                métriques de qualité, etc. (À implémenter)
              </Alert>
            </Box>
          </TabPanel>

          {/* Onglet Commentaires */}
          {task && (
            <TabPanel value={activeTab} index={5}>
              <TaskComments
                taskId={task.id}
                currentUserId={user?.id || ''}
              />
            </TabPanel>
          )}

          {/* Onglet Fichiers */}
          {task && (
            <TabPanel value={activeTab} index={6}>
              <TaskAttachments
                taskId={task.id}
                currentUserId={user?.id || ''}
              />
            </TabPanel>
          )}
        </Box>
      </DialogContent>

      <DialogActions sx={{ p: 3, pt: 1, justifyContent: 'space-between' }}>
        <Box>
          {/* Bouton de suppression - uniquement pour les tâches existantes */}
          {task && task.id && onDelete && (
            <Button
              color="error"
              startIcon={<DeleteIcon />}
              onClick={handleDelete}
              disabled={loading}
              variant="outlined"
            >
              Supprimer
            </Button>
          )}
        </Box>
        <Box sx={{ display: 'flex', gap: 1 }}>
          <Button onClick={onClose}>
            Annuler
          </Button>
          <Button
            variant="contained"
            onClick={handleSave}
            disabled={loading}
          >
            {loading ? 'Enregistrement...' : task ? 'Mettre à jour' : 'Créer'}
          </Button>
        </Box>
      </DialogActions>
    </Dialog>
  );
};