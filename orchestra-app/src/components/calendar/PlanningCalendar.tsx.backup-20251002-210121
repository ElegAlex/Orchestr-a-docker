import React, { useState, useEffect, useCallback, useMemo } from 'react';
import { createPortal } from 'react-dom';
import {
  Box,
  Card,
  CardContent,
  Typography,
  Grid,
  Stack,
  Avatar,
  Chip,
  IconButton,
  Button,
  FormControl,
  Select,
  MenuItem,
  Alert,
  CircularProgress,
  LinearProgress,
  Divider,
  Dialog,
  DialogTitle,
  DialogContent,
  DialogActions,
  Collapse,
} from '@mui/material';
import {
  ChevronLeft as ChevronLeftIcon,
  ChevronRight as ChevronRightIcon,
  Today as TodayIcon,
  ViewWeek as ViewWeekIcon,
  CalendarMonth as CalendarMonthIcon,
  Person as PersonIcon,
  Work as WorkIcon,
  Home as HomeIcon,
  CheckCircle as CheckCircleIcon,
  Schedule as ScheduleIcon,
  Business as BusinessIcon,
  ExpandMore as ExpandMoreIcon,
  ExpandLess as ExpandLessIcon,
  Delete as DeleteIcon,
} from '@mui/icons-material';
import { DndProvider, useDrag, useDrop } from 'react-dnd';
import { HTML5Backend } from 'react-dnd-html5-backend';
import {
  format,
  startOfWeek,
  endOfWeek,
  addDays,
  addWeeks,
  subWeeks,
  isSameDay,
  isToday,
  startOfMonth,
  endOfMonth,
  addMonths,
  subMonths,
  getHours,
  setHours,
  differenceInHours,
  differenceInDays,
  eachDayOfInterval,
} from 'date-fns';
import { fr } from 'date-fns/locale';
import { Task, User, Project, UserCapacity, ResourceAllocation, WorkContract, Department, WeekDay } from '../../types';
import { Service } from '../../types/service';
import { taskService } from '../../services/task.service';
import { simpleTaskService } from '../../services/simpleTask.service';
import { userService } from '../../services/user.service';
import { projectService } from '../../services/project.service';
import { departmentService } from '../../services/department.service';
import { ServiceService } from '../../services/service.service';
import { capacityService } from '../../services/capacity.service';
import { workloadCalculatorService } from '../../services/workload-calculator.service';
import { useTeleworkV2 } from '../../hooks/useTeleworkV2';
import { TeleworkDayCell } from './TeleworkDayCell';
import { TeleworkProfileModal } from './TeleworkProfileModal';
import { TaskModalSimplified as TaskModal } from '../tasks/TaskModalSimplified';
import { auth } from '../../config/firebase';

const serviceService = new ServiceService();

// ========================================
// UTILITAIRES JOURS OUVRABLES
// ========================================

// Mapping des jours de la semaine
const WEEKDAY_MAPPING: Record<number, WeekDay> = {
  1: 'monday',
  2: 'tuesday', 
  3: 'wednesday',
  4: 'thursday',
  5: 'friday',
  6: 'saturday',
  0: 'sunday', // Dimanche = 0 dans getDay()
};

// V√©rifier si un jour est ouvrable pour un utilisateur
const isWorkingDay = (date: Date, contract: WorkContract | null): boolean => {
  if (!contract || !contract.workingDays) {
    // Par d√©faut: lundi √† vendredi
    return date.getDay() >= 1 && date.getDay() <= 5;
  }
  
  const dayOfWeek = WEEKDAY_MAPPING[date.getDay()];
  return contract.workingDays.includes(dayOfWeek);
};

// Filtrer une liste de jours selon les jours ouvrables
const filterWorkingDays = (days: Date[], contracts: Map<string, WorkContract | null>): Date[] => {
  // Si aucun contrat sp√©cifique, garder tous les jours ouvrables standards (lundi-vendredi)
  if (contracts.size === 0) {
    return days.filter(day => day.getDay() >= 1 && day.getDay() <= 5);
  }
  
  // Retourner les jours qui sont ouvrables pour au moins un utilisateur
  return days.filter(day => {
    return Array.from(contracts.values()).some(contract => isWorkingDay(day, contract));
  });
};

// ========================================
// TYPES SPECIFIQUES PLANNING CALENDAR
// ========================================

interface CalendarItem {
  id: string;
  title: string;
  type: 'task' | 'meeting' | 'admin' | 'training' | 'leave' | 'remote' | 'simple_task';
  startTime: Date;
  endTime: Date;
  userId: string;
  projectId?: string;
  project?: Project;
  priority: 'P0' | 'P1' | 'P2' | 'P3';
  status: 'TODO' | 'IN_PROGRESS' | 'BLOCKED' | 'DONE';
  assignee?: User;
  color: string;
  isRemote: boolean;
  canMove: boolean;
  canResize: boolean;
  // Nouveaux champs pour les t√¢ches multi-jours
  originalTaskId?: string; // ID de la t√¢che originale
  isSpanning?: boolean; // Indique si la t√¢che s'√©tend sur plusieurs jours
  spanDay?: number; // Jour actuel dans la s√©quence (1, 2, 3...)
  totalSpanDays?: number; // Nombre total de jours de la t√¢che
  taskCount?: number; // Nombre de t√¢ches regroup√©es dans cette card projet
  // Nouveaux champs pour l'affichage enrichi
  progress?: number; // Progression 0-100%
  estimatedHours?: number; // Heures estim√©es
  daysRemaining?: number; // Jours restants avant deadline
  // Cr√©neaux horaires en string (pour t√¢ches simples)
  startTimeString?: string; // Format "HH:mm"
  endTimeString?: string; // Format "HH:mm"
}

interface UserWorkloadDay {
  userId: string;
  user: User;
  date: Date;
  capacity: number; // En heures (ex: 7)
  allocated: number; // En heures d√©j√† allou√©es
  items: CalendarItem[];
  isRemoteWork: boolean;
  utilizationRate: number; // 0-100%
  contract: WorkContract | null;
}


type ViewMode = 'week' | 'month';

// ========================================
// ENHANCED TASK CARD COMPONENT
// ========================================

// Fonction pour g√©n√©rer une carte de t√¢che enrichie
const renderEnhancedTaskCard = (item: CalendarItem, onClick: (item: CalendarItem) => void, compact = false) => {
  const isSimpleTask = item.type === 'simple_task';
  const isPriorityCritical = item.priority === 'P0';
  const isOverdue = (item.daysRemaining || 0) < 0;
  const isUrgent = (item.daysRemaining || 0) <= 1 && !isOverdue;

  // Icone selon le type
  const getTaskIcon = () => {
    if (isSimpleTask) return '‚ö°'; // √âclair pour t√¢ches simples
    if (item.project) return 'üìÅ'; // Dossier pour projets
    return 'üìã'; // Presse-papier par d√©faut
  };

  // Couleur de priorit√©
  const getPriorityColor = () => {
    switch (item.priority) {
      case 'P0': return '#f44336'; // Rouge
      case 'P1': return '#ff9800'; // Orange
      case 'P2': return '#2196f3'; // Bleu
      case 'P3': return '#9e9e9e'; // Gris
      default: return item.color;
    }
  };

  return (
    <Box
      sx={{
        bgcolor: item.color,
        color: 'white',
        borderRadius: 1,
        p: compact ? 0.5 : 1,
        cursor: 'pointer',
        position: 'relative',
        overflow: 'hidden',
        minHeight: compact ? 32 : 56,
        border: isPriorityCritical ? '2px solid #f44336' : 'none',
        boxShadow: compact ? 1 : 2,
        '&:hover': {
          opacity: 0.9,
          transform: 'translateY(-1px)',
          boxShadow: 3
        },
        transition: 'all 0.2s ease'
      }}
      onClick={() => onClick(item)}
    >
      {/* Badge priorit√© critique */}
      {isPriorityCritical && (
        <Box
          sx={{
            position: 'absolute',
            top: 0,
            right: 0,
            bgcolor: '#f44336',
            color: 'white',
            fontSize: '0.6rem',
            px: 0.5,
            borderBottomLeftRadius: 4
          }}
        >
          URGENT
        </Box>
      )}

      {/* Header avec ic√¥ne et projet */}
      <Stack direction="row" alignItems="center" spacing={0.5} mb={compact ? 0 : 0.5}>
        <Typography sx={{ fontSize: '0.8rem' }}>{getTaskIcon()}</Typography>
        {item.project && !compact && (
          <Chip
            label={item.project.name}
            size="small"
            sx={{
              bgcolor: 'rgba(255,255,255,0.2)',
              color: 'white',
              fontSize: '0.6rem',
              height: 16
            }}
          />
        )}
        <Box flexGrow={1} />
        {item.estimatedHours && (
          <Typography variant="caption" sx={{ fontSize: '0.6rem', opacity: 0.8 }}>
            {item.estimatedHours}h
          </Typography>
        )}
      </Stack>

      {/* Titre de la t√¢che */}
      <Typography
        variant={compact ? "caption" : "body2"}
        fontWeight="medium"
        sx={{
          fontSize: compact ? '0.65rem' : '0.8rem',
          lineHeight: 1.2,
          mb: compact ? 0 : 0.5,
          display: '-webkit-box',
          WebkitLineClamp: compact ? 1 : 2,
          WebkitBoxOrient: 'vertical',
          overflow: 'hidden'
        }}
        title={item.title}
      >
        {item.title}
      </Typography>

      {/* Affichage des horaires pour les t√¢ches simples */}
      {(() => {
        const shouldDisplay = item.type === 'simple_task' && item.startTimeString && item.endTimeString;
        console.log('üéØ RENDER CHECK:', {
          title: item.title,
          type: item.type,
          startTimeString: item.startTimeString,
          endTimeString: item.endTimeString,
          shouldDisplay
        });
        return shouldDisplay ? (
          <Typography
            variant="caption"
            sx={{
              fontSize: '0.65rem',
              color: 'rgba(255,255,255,0.9)',
              fontWeight: 'bold',
              display: 'block',
              mb: 0.5
            }}
          >
            {`üïê ${item.startTimeString} - ${item.endTimeString}`}
          </Typography>
        ) : null;
      })()}

      {/* Barre de progression et infos (mode non compact) */}
      {!compact && (
        <>
          {typeof item.progress === 'number' && (
            <Box sx={{ mb: 0.5 }}>
              <Stack direction="row" alignItems="center" spacing={0.5}>
                <Box flexGrow={1}>
                  <LinearProgress
                    variant="determinate"
                    value={item.progress}
                    sx={{
                      height: 3,
                      borderRadius: 1,
                      bgcolor: 'rgba(255,255,255,0.2)',
                      '& .MuiLinearProgress-bar': {
                        bgcolor: 'rgba(255,255,255,0.8)'
                      }
                    }}
                  />
                </Box>
                <Typography variant="caption" sx={{ fontSize: '0.6rem' }}>
                  {item.progress}%
                </Typography>
              </Stack>
            </Box>
          )}

          {/* Footer avec statut et deadline */}
          <Stack direction="row" alignItems="center" justifyContent="space-between">
            <Chip
              label={item.status}
              size="small"
              sx={{
                bgcolor: 'rgba(255,255,255,0.15)',
                color: 'white',
                fontSize: '0.5rem',
                height: 14
              }}
            />
            {typeof item.daysRemaining === 'number' && (
              <Typography
                variant="caption"
                sx={{
                  fontSize: '0.6rem',
                  color: isOverdue ? '#ffcdd2' : isUrgent ? '#ffe0b2' : 'rgba(255,255,255,0.8)'
                }}
              >
                {isOverdue ? `Retard ${Math.abs(item.daysRemaining)}j` :
                 item.daysRemaining === 0 ? 'Aujourd\'hui' :
                 `J-${item.daysRemaining}`}
              </Typography>
            )}
          </Stack>
        </>
      )}
    </Box>
  );
};

// ========================================
// DRAG & DROP ITEM COMPONENT
// ========================================

interface DraggableItemProps {
  item: CalendarItem;
  onMove: (itemId: string, newStartTime: Date, newEndTime: Date, newUserId?: string) => void;
  onResize: (itemId: string, newStartTime: Date, newEndTime: Date) => void;
  onClick: (item: CalendarItem) => void;
}

const DraggableItem: React.FC<DraggableItemProps> = ({ item, onMove, onResize, onClick }) => {
  const [{ isDragging }, drag] = useDrag(() => ({
    type: 'calendar-item',
    item: { ...item },
    canDrag: item.canMove,
    collect: (monitor) => ({
      isDragging: monitor.isDragging(),
    }),
  }));

  const getItemIcon = () => {
    switch (item.type) {
      case 'task': return <WorkIcon fontSize="small" />;
      case 'meeting': return <PersonIcon fontSize="small" />;
      case 'admin': return <BusinessIcon fontSize="small" />;
      case 'training': return <ScheduleIcon fontSize="small" />;
      case 'remote': return <HomeIcon fontSize="small" />;
      default: return <WorkIcon fontSize="small" />;
    }
  };

  const getItemColor = () => {
    if (item.isRemote) return '#9c27b0'; // Violet t√©l√©travail
    return item.color || '#2196f3';
  };

  const duration = differenceInHours(item.endTime, item.startTime);

  return (
    <Box
      ref={drag as any}
      onClick={() => onClick(item)}
      sx={{
        bgcolor: getItemColor(),
        color: 'white',
        borderRadius: 1,
        p: 0.5,
        mb: 0.5,
        cursor: item.canMove ? 'move' : 'default',
        opacity: isDragging ? 0.5 : 1,
        height: 40,
        display: 'flex',
        alignItems: 'center',
        overflow: 'hidden',
        gap: 0.5,
        border: 'none',
        '&:hover': {
          opacity: 0.8,
          boxShadow: 2,
        },
      }}
    >
      {getItemIcon()}
      <Box flexGrow={1} sx={{ minWidth: 0 }}>
        <Typography variant="caption" noWrap fontWeight="bold" sx={{ fontSize: '0.75rem' }}>
          üìã {item.title}
          {item.taskCount && item.taskCount > 1 && (
            <Chip
              label={item.taskCount}
              size="small"
              color="primary"
              sx={{
                height: 16,
                fontSize: '0.6rem',
                ml: 0.5,
                minWidth: 20
              }}
            />
          )}
        </Typography>
        {item.type === 'simple_task' && item.startTimeString && item.endTimeString && (
          <Typography variant="caption" display="block" sx={{ opacity: 0.9, fontSize: '0.65rem', fontWeight: 'bold' }}>
            üïê {item.startTimeString} - {item.endTimeString}
          </Typography>
        )}
        {item.isSpanning && item.spanDay && item.totalSpanDays && item.totalSpanDays > 1 && (
          <Typography variant="caption" display="block" sx={{ opacity: 0.7, fontSize: '0.65rem' }}>
            Jour {item.spanDay}/{item.totalSpanDays}
          </Typography>
        )}
      </Box>
      {item.isRemote && (
        <Chip 
          size="small" 
          label="TT" 
          sx={{ 
            height: 16, 
            bgcolor: 'rgba(255,255,255,0.2)', 
            color: 'white',
            fontSize: '0.6rem'
          }} 
        />
      )}
    </Box>
  );
};

// ========================================
// DYNAMIC TASK SLOT COMPONENT
// ========================================

interface TaskSlotProps {
  userId: string;
  date: Date;
  slotIndex: number;
  item?: CalendarItem;
  isEmpty: boolean;
  onDrop: (item: CalendarItem, userId: string, date: Date, slotIndex: number) => void;
  onCreateTask: (userId: string, date: Date) => void;
  onItemClick: (item: CalendarItem) => void;
}

const TaskSlot: React.FC<TaskSlotProps> = ({ 
  userId, 
  date, 
  slotIndex, 
  item, 
  isEmpty, 
  onDrop, 
  onCreateTask,
  onItemClick 
}) => {
  const [{ isOver, canDrop }, drop] = useDrop(() => ({
    accept: 'calendar-item',
    canDrop: (item: CalendarItem) => {
      return true; // Validation plus tard
    },
    drop: (draggedItem: CalendarItem) => {
      onDrop(draggedItem, userId, date, slotIndex);
    },
    collect: (monitor) => ({
      isOver: monitor.isOver(),
      canDrop: monitor.canDrop(),
    }),
  }));

  const handleSlotClick = () => {
    if (isEmpty && !item) {
      onCreateTask(userId, date);
    } else if (item) {
      onItemClick(item);
    }
  };

  return (
    <Box
      ref={drop as any}
      onClick={handleSlotClick}
      sx={{
        width: '100%', // Prendre toute la largeur disponible
        height: 40,
        border: '1px dashed',
        borderColor: isOver ? 'primary.main' : isEmpty ? 'grey.300' : 'transparent',
        bgcolor: isOver && canDrop ? 'primary.light' : 
                isEmpty ? 'grey.50' : 'transparent',
        borderRadius: 1,
        p: 0.5,
        mb: 0.5,
        cursor: isEmpty || item ? 'pointer' : 'default',
        transition: 'all 0.2s ease',
        display: 'flex',
        alignItems: 'center',
        justifyContent: isEmpty && !item ? 'center' : 'flex-start',
        overflow: 'hidden', // Emp√™che le d√©bordement
        '&:hover': isEmpty || item ? {
          bgcolor: 'grey.100',
          borderColor: 'primary.main',
        } : {},
      }}
    >
      {item ? (
        <DraggableItem
          item={item}
          onMove={() => {}}
          onResize={() => {}}
          onClick={onItemClick}
        />
      ) : isEmpty ? (
        <Typography 
          variant="caption" 
          color="text.secondary"
          sx={{ 
            fontSize: '0.7rem',
            fontStyle: 'italic',
            display: 'flex',
            alignItems: 'center',
            gap: 0.5
          }}
        >
          + Ajouter t√¢che
        </Typography>
      ) : null}
    </Box>
  );
};


// ========================================
// USER ROW COMPONENT
// ========================================

interface UserRowProps {
  workloadDay: UserWorkloadDay;
  viewMode: ViewMode;
  weekDays: Date[];
  departments: Department[];
  userContracts: Map<string, WorkContract | null>;
  currentUserId: string;
  teleworkSystem: any; // Type du hook v2
  onItemMove: (itemId: string, newStartTime: Date, newEndTime: Date, newUserId?: string) => void;
  onItemClick: (item: CalendarItem) => void;
  onItemDrop: (item: CalendarItem, userId: string, date: Date, slotIndex: number) => void;
  onCreateTask: (userId: string, date: Date) => void;
  onTeleworkModeChange: (userId: string, date: Date, mode: 'office' | 'remote') => Promise<void>;
  onTeleworkProfileConfig: (userId: string) => void;
  onTeleworkDetails: (userId: string, date: Date) => void;
}

const UserRow: React.FC<UserRowProps> = ({
  workloadDay,
  viewMode,
  weekDays,
  departments,
  userContracts,
  currentUserId,
  teleworkSystem,
  onItemMove,
  onItemClick,
  onItemDrop,
  onCreateTask,
  onTeleworkModeChange,
  onTeleworkProfileConfig,
  onTeleworkDetails,
}) => {
  const getUtilizationColor = (rate: number) => {
    if (rate <= 60) return 'success';
    if (rate <= 85) return 'warning';
    if (rate <= 100) return 'info';
    return 'error';
  };

  const renderDayColumn = (date: Date) => {
    const dayItems = workloadDay.items.filter(item =>
      isSameDay(item.startTime, date)
    );

    // V√©rifier si l'utilisateur est en t√©l√©travail ce jour avec le nouveau syst√®me unifi√©
    const year = date.getFullYear();
    const month = String(date.getMonth() + 1).padStart(2, '0');
    const day = String(date.getDate()).padStart(2, '0');
    const dateStr = `${year}-${month}-${day}`;
    const teleworkDayKey = `${workloadDay.userId}_${dateStr}`;
    const teleworkResolution = teleworkSystem.getResolutionForDay(workloadDay.userId, date);
    const isRemoteDay = teleworkResolution?.resolvedMode === 'remote' || false;

    // Logique dynamique: 1 slot minimum + 1 slot par t√¢che existante
    const minSlots = 1;
    const totalSlots = Math.max(minSlots, dayItems.length + 1);

    const taskSlots = Array.from({ length: totalSlots }, (_, slotIndex) => {
      const item = dayItems[slotIndex] || undefined;
      const isEmpty = !item && slotIndex >= dayItems.length;

      return (
        <TaskSlot
          key={`${date.toISOString()}-slot-${slotIndex}`}
          userId={workloadDay.userId}
          date={date}
          slotIndex={slotIndex}
          item={item}
          isEmpty={isEmpty}
          onDrop={onItemDrop}
          onCreateTask={onCreateTask}
          onItemClick={onItemClick}
        />
      );
    });

    return (
      <Box key={date.toISOString()} sx={{
        width: 160, // Largeur fixe pour homog√©n√©it√©
        minWidth: 160,
        maxWidth: 160,
        p: 0.5,
        display: 'flex',
        flexDirection: 'column',
        bgcolor: isRemoteDay ? 'rgba(156, 39, 176, 0.05)' : 'transparent', // Violet pour t√©l√©travail
        borderRadius: 1,
        position: 'relative'
      }}>
        {/* Indicateur t√©l√©travail en haut de la colonne */}
        {isRemoteDay && (
          <Box
            sx={{
              position: 'absolute',
              top: 2,
              right: 2,
              bgcolor: teleworkResolution?.source === 'override' ? 'warning.main' : 'secondary.main',
              color: 'white',
              borderRadius: 0.5,
              px: 0.5,
              py: 0.1,
              fontSize: '0.6rem',
              fontWeight: 'bold',
              zIndex: 1,
              border: teleworkResolution?.source === 'override' ? '2px solid' : 'none',
              borderColor: teleworkResolution?.source === 'override' ? 'warning.dark' : 'transparent'
            }}
            title={teleworkResolution?.source === 'override' ? 'T√©l√©travail ponctuel' : 'T√©l√©travail'}
          >
            {teleworkResolution?.source === 'override' ? 'üè†!' : 'TT'}
          </Box>
        )}

        {/* Slots dynamiques de t√¢ches */}
        <Stack spacing={0.5}>
          {taskSlots}
        </Stack>
      </Box>
    );
  };

  return (
    <Card sx={{ mb: 1 }}>
      <CardContent sx={{ p: 1 }}>
        <Box sx={{ display: "flex", alignItems: "stretch", gap: 1 }}>
          {/* Zone utilisateur SANCTUARIS√âE - largeur fixe */}
          <Box sx={{ 
            width: 240, 
            minWidth: 240,
            maxWidth: 240,
            flexShrink: 0, // Emp√™che la compression
            borderRight: '1px solid',
            borderColor: 'divider',
            pr: 1
          }}>
            <Stack direction="row" alignItems="center" spacing={1}>
              <Avatar 
                src={workloadDay.user.avatarUrl} 
                sx={{ width: 32, height: 32 }}
              >
                {workloadDay.user.firstName?.[0]}{workloadDay.user.lastName?.[0]}
              </Avatar>
              
              <Box sx={{ flex: 1, minWidth: 0 }}>
                <Typography
                  variant="body2"
                  fontWeight="bold"
                  noWrap
                  sx={{ fontSize: '0.85rem' }}
                >
                  {getUserDisplayName(workloadDay.user)}
                </Typography>

                {/* Indicateurs conflits */}
              </Box>
            </Stack>

            {/* Boutons t√©l√©travail avec le nouveau syst√®me */}
            <Box sx={{ display: 'flex', gap: 0.5, flexWrap: 'wrap' }}>
              {weekDays.map((day) => {
                const resolution = teleworkSystem.getResolutionForDay(workloadDay.userId, day);

                return (
                  <TeleworkDayCell
                    key={`${workloadDay.userId}_${day.toISOString()}`}
                    resolution={resolution || {
                      date: day,
                      userId: workloadDay.userId,
                      resolvedMode: 'office',
                      source: 'default',
                      confidence: 70,
                      appliedRules: {},
                      conflicts: [],
                      warnings: []
                    }}
                    isEditable={currentUserId === workloadDay.userId || true} // TODO: Check permissions
                    size="small"
                    showDetails={false}
                    onModeChange={async (mode) => {
                      await onTeleworkModeChange(workloadDay.userId, day, mode);
                    }}
                    onRequestOverride={async (mode, reason) => {
                      await teleworkSystem.requestOverride(workloadDay.userId, day, mode, reason);
                    }}
                    onConfigureProfile={() => onTeleworkProfileConfig(workloadDay.userId)}
                    onViewDetails={() => onTeleworkDetails(workloadDay.userId, day)}
                  />
                );
              })}
            </Box>
          </Box>

          {/* Zone des jours - s'adapte au reste */}
          <Box sx={{ 
            flex: 1,
            minWidth: 0,
            overflowX: 'auto'
          }}>
            <Stack direction="row" spacing={0.5}>
              {viewMode === 'week' ? (
                weekDays.map((day) => {
                  // R√©cup√©rer le contrat de cet utilisateur sp√©cifique
                  const userContract = userContracts.get(workloadDay.userId) || null;
                  
                  // Si l'utilisateur ne travaille pas ce jour, ne pas afficher la colonne
                  if (!isWorkingDay(day, userContract)) {
                    return (
                      <Box 
                        key={day.toISOString()}
                        sx={{ 
                          width: 160, 
                          minWidth: 160, 
                          maxWidth: 160,
                          p: 0.5,
                          display: 'flex',
                          alignItems: 'center',
                          justifyContent: 'center',
                          bgcolor: 'grey.100',
                          color: 'text.disabled',
                          borderRadius: 1
                        }}
                      >
                        <Typography variant="caption" sx={{ fontSize: '0.7rem' }}>
                          Non travaill√©
                        </Typography>
                      </Box>
                    );
                  }
                  
                  return renderDayColumn(day);
                })
              ) : (
                // Vue mensuelle simplifi√©e
                <Box>Vue mensuelle √† impl√©menter</Box>
              )}
            </Stack>
          </Box>
        </Box>
      </CardContent>
    </Card>
  );
};


// ========================================
// MAIN PLANNING CALENDAR COMPONENT
// ========================================

interface PlanningCalendarProps {
  selectedProjects?: string[];
  selectedUsers?: string[];
  onTaskUpdate?: (taskId: string, updates: Partial<Task>) => void;
}

// Helper pour obtenir le nom d'affichage correct d'un utilisateur
const getUserDisplayName = (user: User): string => {
  if (user.displayName && user.displayName !== user.id) {
    return user.displayName;
  }
  const fullName = `${user.firstName || ''} ${user.lastName || ''}`.trim();
  return fullName || user.email || 'Utilisateur inconnu';
};


const PlanningCalendar: React.FC<PlanningCalendarProps> = ({
  selectedProjects = [],
  selectedUsers = [],
  onTaskUpdate,
}) => {
  // √âtats principaux
  const [currentDate, setCurrentDate] = useState(new Date());
  const [viewMode, setViewMode] = useState<ViewMode>('week');
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  
  // Donn√©es
  const [users, setUsers] = useState<User[]>([]);
  const [projects, setProjects] = useState<Project[]>([]);
  const [departments, setDepartments] = useState<Department[]>([]);
  const [services, setServices] = useState<Service[]>([]);
  const [rawWorkloadDays, setRawWorkloadDays] = useState<UserWorkloadDay[]>([]);
  const [expandedServices, setExpandedServices] = useState<Set<string>>(new Set());
  const [userContracts, setUserContracts] = useState<Map<string, WorkContract | null>>(new Map());

  // Calcul des dates du calendrier pour le hook t√©l√©travail
  const weekDays = useMemo(() => {
    const start = startOfWeek(currentDate, { locale: fr });
    const allWeekDays = Array.from({ length: 7 }, (_, i) => addDays(start, i));
    // Filtrer selon les jours ouvrables des utilisateurs
    return filterWorkingDays(allWeekDays, userContracts);
  }, [currentDate, userContracts]);

  // Calculer la plage √©tendue pour le calendrier t√©l√©travail (p√©riode visible + marge)
  const teleworkDateRange = useMemo(() => {
    const start = new Date(weekDays[0] || currentDate);
    start.setDate(start.getDate() - 15); // 15 jours avant
    const end = new Date(weekDays[weekDays.length - 1] || currentDate);
    end.setDate(end.getDate() + 15); // 15 jours apr√®s
    return { start, end };
  }, [weekDays, currentDate]);

  // UserIds stable pour √©viter les re-renders infinis
  const userIds = useMemo(() => users.map(u => u.id), [users]);

  // Hook pour la gestion du t√©l√©travail avec le nouveau syst√®me v2
  const teleworkSystem = useTeleworkV2({
    userIds,
    dateRange: teleworkDateRange,
    autoRefresh: true
  });

  // Appliquer les donn√©es t√©l√©travail aux workloadDays
  const workloadDays = useMemo(() => {
    return rawWorkloadDays.map(workloadDay => {
      const teleworkResolution = teleworkSystem.getResolutionForDay(workloadDay.userId, workloadDay.date);
      const isRemoteWork = teleworkResolution?.resolvedMode === 'remote';
      return { ...workloadDay, isRemoteWork };
    });
  }, [rawWorkloadDays, teleworkSystem.weekResolutions.size, teleworkSystem]);

  // UI √âtats
  const [selectedItem, setSelectedItem] = useState<CalendarItem | null>(null);
  const [draggedItem, setDraggedItem] = useState<CalendarItem | null>(null);
  
  // √âtats TaskModal
  const [taskModalOpen, setTaskModalOpen] = useState(false);
  const [taskModalData, setTaskModalData] = useState<{
    userId?: string;
    date?: Date;
    projectId?: string;
    task?: Task | null;
  }>({});

  // Helper pour obtenir le nom du d√©partement par son ID
  const getDepartmentName = (departmentId: string | undefined): string => {
    if (!departmentId) return '-';
    const department = departments.find(dept => dept.id === departmentId);
    return department?.name || '-';
  };

  // Fonction pour basculer l'√©tat d'un service
  const toggleService = (serviceId: string) => {
    const newExpanded = new Set(expandedServices);
    if (newExpanded.has(serviceId)) {
      newExpanded.delete(serviceId);
    } else {
      newExpanded.add(serviceId);
    }
    setExpandedServices(newExpanded);
  };

  // Grouper les workloadDays par service avec gestion sp√©ciale de l'encadrement
  const workloadDaysByService = useMemo(() => {
    const grouped = new Map<string, UserWorkloadDay[]>();
    
    workloadDays.forEach(workloadDay => {
      // Les managers et responsables vont dans "Encadrement"
      if (workloadDay.user.role === 'manager' || workloadDay.user.role === 'responsable') {
        const encadrementKey = 'encadrement';
        if (!grouped.has(encadrementKey)) {
          grouped.set(encadrementKey, []);
        }
        grouped.get(encadrementKey)!.push(workloadDay);
      } else {
        // Autres utilisateurs vont dans leur service
        const service = workloadDay.user.serviceIds?.[0] || workloadDay.user.serviceId || 'no-service';
        if (!grouped.has(service)) {
          grouped.set(service, []);
        }
        grouped.get(service)!.push(workloadDay);
      }
    });

    // Trier par nom de service avec "Encadrement" en premier
    const sortedEntries = Array.from(grouped.entries()).sort(([serviceA], [serviceB]) => {
      if (serviceA === 'encadrement') return -1;
      if (serviceB === 'encadrement') return 1;
      
      const nameA = serviceA === 'no-service' ? 'Sans service' : serviceA;
      const nameB = serviceB === 'no-service' ? 'Sans service' : serviceB;
      return nameA.localeCompare(nameB);
    });

    return new Map(sortedEntries);
  }, [workloadDays]);

  // P√©riode actuelle calcul√©e
  const currentPeriod = useMemo(() => {
    if (viewMode === 'week') {
      return {
        start: startOfWeek(currentDate, { locale: fr }),
        end: endOfWeek(currentDate, { locale: fr }),
      };
    } else {
      return {
        start: startOfMonth(currentDate),
        end: endOfMonth(currentDate),
      };
    }
  }, [currentDate, viewMode]);


  // ========================================
  // DATA LOADING
  // ========================================

  const loadCalendarData = useCallback(async () => {
    try {
      setLoading(true);
      setError(null);

      // Charger les donn√©es de base
      const [allUsers, allProjects, allDepartments, allServices] = await Promise.all([
        userService.getAllUsers(),
        projectService.getAllProjects(),
        departmentService.getAllDepartments(),
        serviceService.getAllServices(),
      ]);

      // Filtrer selon les s√©lections et exclure les admins
      const filteredUsers = selectedUsers.length > 0
        ? allUsers.filter(u => selectedUsers.includes(u.id) && u.role !== 'admin')
        : allUsers.filter(u => u.isActive && u.role !== 'admin');

      // Debug info cleaned up

      const filteredProjects = selectedProjects.length > 0
        ? allProjects.filter(p => selectedProjects.includes(p.id))
        : allProjects;

      setUsers(filteredUsers);
      setProjects(filteredProjects);
      setDepartments(allDepartments);
      setServices(allServices);

      // Charger les contrats de travail des utilisateurs filtr√©s
      const contractsMap = new Map<string, WorkContract | null>();

      await Promise.all(
        filteredUsers.map(async (user) => {
          try {
            // Charger le contrat
            const contract = await capacityService.getUserContract(user.id);
            contractsMap.set(user.id, contract);
          } catch (error) {
            console.warn(`Impossible de charger le contrat pour ${user.displayName}:`, error);
            contractsMap.set(user.id, null);
          }
        })
      );
      setUserContracts(contractsMap);

      // Ouvrir tous les services par d√©faut + encadrement
      const services = new Set(filteredUsers.map(user => {
        if (user.role === 'manager' || user.role === 'responsable') {
          return 'encadrement';
        }
        return user.serviceIds?.[0] || user.serviceId || 'no-service';
      }));
      setExpandedServices(services);

      // Calculer la charge de travail pour chaque utilisateur et chaque jour
      const workloadPromises = [];
      
      // G√©n√©rer les dates selon la vue
      const dates = viewMode === 'week' 
        ? [currentDate] // Une seule entr√©e pour la vue semaine
        : (() => {
            // G√©n√©rer toutes les dates du mois pour la vue mensuelle
            const monthDates = [];
            let date = startOfMonth(currentDate);
            const monthEnd = endOfMonth(currentDate);
            while (date <= monthEnd) {
              monthDates.push(new Date(date));
              date = addDays(date, 1);
            }
            return monthDates;
          })();

      // Pour chaque utilisateur et chaque date
      for (const user of filteredUsers) {
        for (const date of dates) {
          workloadPromises.push(async () => {
            try {
              // ‚úÖ R√©cup√©rer TOUTES les t√¢ches et appliquer le filtre RACI comme Dashboard-Hub
              const [allTasks, allSimpleTasks] = await Promise.all([
                taskService.getTasks(), // Toutes les t√¢ches
                simpleTaskService.getAll().catch(() => []) // Toutes les t√¢ches simples
              ]);

              // Filtrer les t√¢ches simples pour cet utilisateur
              const userSimpleTasks = allSimpleTasks.filter(task =>
                task.assignedTo === user.id
              );

              // Convertir SimpleTasks en format Task
              const simpleTasksAsTaskFormat: Task[] = userSimpleTasks.map(st => ({
                id: st.id,
                title: st.title,
                description: st.description,
                projectId: '',
                taskCategory: 'SIMPLE_TASK' as any,
                priority: st.priority,
                status: st.status,
                type: 'TASK' as any,
                dueDate: st.date,
                startDate: st.date,
                startTime: st.timeSlot.start,
                endTime: st.timeSlot.end,
                responsible: [st.assignedTo],
                createdBy: st.createdBy,
                createdAt: st.createdAt,
                updatedAt: st.updatedAt,
                dependencies: [],
                labels: [],
                attachments: [],
                comments: [],
              } as any));

              // Filtrer uniquement les t√¢ches o√π l'utilisateur est RESPONSABLE
              const userTasks = allTasks.filter(task => {
                // V√©rifier si l'user est responsable de la t√¢che UNIQUEMENT
                return Array.isArray(task.responsible) && task.responsible.includes(user.id);
              });

              // Combiner toutes les t√¢ches
              const allUserTasks = [...userTasks, ...simpleTasksAsTaskFormat];

              // ‚úÖ Calendar g√©n√©ral : AUCUN filtrage par p√©riode, afficher toutes les t√¢ches
              const periodTasks = allUserTasks.filter(task => {
                // Une t√¢che doit avoir au moins dueDate ou startDate
                if (!task.startDate && !task.dueDate) {
                  return false;
                }
                return true; // Toutes les t√¢ches avec dates sont incluses
              });

          // ‚úÖ NOUVELLE LOGIQUE : 1 carte = 1 t√¢che (pas de regroupement par projet)
          const calendarItems: CalendarItem[] = [];

          // ‚úÖ Pour chaque t√¢che individuelle, cr√©er un CalendarItem
          periodTasks.forEach(task => {
            const isSimpleTask = (task as any).taskCategory === 'SIMPLE_TASK';
            const projectId = task.projectId;
            const project = projectId ? filteredProjects.find(p => p.id === projectId) : undefined;
            const isUnassigned = !projectId && !isSimpleTask;

            // Calculer les dates de la t√¢che individuelle
            const taskStart = task.startDate ? new Date(task.startDate as any) :
                             task.dueDate ? new Date(task.dueDate as any) : null;
            const taskEnd = task.dueDate ? new Date(task.dueDate as any) :
                           task.startDate ? new Date(task.startDate as any) : null;

            if (!taskStart || !taskEnd) return; // Skip si aucune date

            const totalDays = Math.max(1, differenceInDays(taskEnd, taskStart) + 1);
            const isMultiDay = totalDays > 1;

            // Calculer la progression de la t√¢che
            const progress = task.estimatedHours && task.loggedHours ?
              Math.min(100, Math.round((task.loggedHours / task.estimatedHours) * 100)) : 0;

            // D√©terminer la couleur selon le type et le projet
            const getTaskColor = () => {
              if (isSimpleTask) return '#9c27b0'; // Violet pour t√¢ches simples
              if (isUnassigned) return '#757575'; // Gris pour non assign√©es
              if (project) {
                // Couleur selon priorit√©/urgence du projet
                if (project.tags?.includes('urgent')) return '#f44336';
                if (project.priority === 'P0') return '#f44336'; // Rouge critique
                if (project.priority === 'P1') return '#ff9800'; // Orange important
                return '#2196f3'; // Bleu par d√©faut
              }
              return '#2196f3';
            };

            if (viewMode === 'week') {
              // En vue hebdomadaire, cr√©er une CalendarItem par jour de la t√¢che
              if (isMultiDay) {
                const taskDays = eachDayOfInterval({ start: taskStart, end: taskEnd });

                taskDays.forEach((day, index) => {
                  // V√©rifier si ce jour est dans la p√©riode affich√©e
                  if (day >= currentPeriod.start && day <= currentPeriod.end) {
                    // Extraire les heures de task.startTime et task.endTime si pr√©sents
                    const startHour = task.startTime ? parseInt(task.startTime.split(':')[0]) : 9;
                    const startMinute = task.startTime ? parseInt(task.startTime.split(':')[1]) : 0;
                    const endHour = task.endTime ? parseInt(task.endTime.split(':')[0]) : 17;
                    const endMinute = task.endTime ? parseInt(task.endTime.split(':')[1]) : 0;

                    calendarItems.push({
                      id: `${task.id}-${format(day, 'yyyy-MM-dd')}`,
                      originalTaskId: task.id,
                      title: task.title, // Titre de la T√ÇCHE, pas du projet!
                      type: isSimpleTask ? 'simple_task' : 'task',
                      startTime: new Date(day.getFullYear(), day.getMonth(), day.getDate(), startHour, startMinute),
                      endTime: new Date(day.getFullYear(), day.getMonth(), day.getDate(), endHour, endMinute),
                      userId: user.id,
                      projectId: projectId,
                      project,
                      priority: task.priority as 'P0' | 'P1' | 'P2' | 'P3',
                      status: task.status as any,
                      assignee: user,
                      color: getTaskColor(),
                      isRemote: false,
                      canMove: true,
                      canResize: false,
                      isSpanning: true,
                      spanDay: index + 1,
                      totalSpanDays: totalDays,
                      // Nouvelles propri√©t√©s pour l'affichage enrichi
                      progress,
                      estimatedHours: task.estimatedHours,
                      daysRemaining: differenceInDays(taskEnd, new Date()),
                    });
                  }
                });
              } else {
                // T√¢che d'un seul jour
                if (taskStart >= currentPeriod.start && taskStart <= currentPeriod.end) {
                  // Extraire les heures de task.startTime et task.endTime si pr√©sents
                  const startHour = task.startTime ? parseInt(task.startTime.split(':')[0]) : 9;
                  const startMinute = task.startTime ? parseInt(task.startTime.split(':')[1]) : 0;
                  const endHour = task.endTime ? parseInt(task.endTime.split(':')[0]) : 17;
                  const endMinute = task.endTime ? parseInt(task.endTime.split(':')[1]) : 0;

                  calendarItems.push({
                    id: task.id,
                    originalTaskId: task.id,
                    title: task.title, // Titre de la T√ÇCHE
                    type: isSimpleTask ? 'simple_task' : 'task',
                    startTime: new Date(taskStart.getFullYear(), taskStart.getMonth(), taskStart.getDate(), startHour, startMinute),
                    endTime: new Date(taskStart.getFullYear(), taskStart.getMonth(), taskStart.getDate(), endHour, endMinute),
                    startTimeString: task.startTime, // String originale "09:00"
                    endTimeString: task.endTime, // String originale "17:00"
                    userId: user.id,
                    projectId: projectId,
                    project,
                    priority: task.priority as 'P0' | 'P1' | 'P2' | 'P3',
                    status: task.status as any,
                    assignee: user,
                    color: getTaskColor(),
                    isRemote: false,
                    canMove: true,
                    canResize: true,
                    isSpanning: false,
                    progress,
                    estimatedHours: task.estimatedHours,
                    daysRemaining: differenceInDays(taskEnd, new Date()),
                  });

                  // DEBUG: Log pour v√©rifier les horaires
                  if (isSimpleTask) {
                    console.log('üîç CalendarItem cr√©√©:', {
                      title: task.title,
                      startTimeString: task.startTime,
                      endTimeString: task.endTime,
                      type: 'simple_task'
                    });
                  }
                }
              }
            } else {
              // En vue mensuelle - v√©rifier si la t√¢che est active ce jour
              const isTaskActiveOnDay = isSameDay(taskStart, date) ||
                                        isSameDay(taskEnd, date) ||
                                        (taskStart <= date && taskEnd >= date);

              if (isTaskActiveOnDay) {
                const dayIndex = Math.max(0, differenceInDays(date, taskStart));

                // Extraire les heures de task.startTime et task.endTime si pr√©sents
                const startHour = task.startTime ? parseInt(task.startTime.split(':')[0]) : 9;
                const startMinute = task.startTime ? parseInt(task.startTime.split(':')[1]) : 0;
                const endHour = task.endTime ? parseInt(task.endTime.split(':')[0]) : 17;
                const endMinute = task.endTime ? parseInt(task.endTime.split(':')[1]) : 0;

                calendarItems.push({
                  id: `${task.id}-${format(date, 'yyyy-MM-dd')}`,
                  originalTaskId: task.id,
                  title: task.title, // Titre de la T√ÇCHE
                  type: isSimpleTask ? 'simple_task' : 'task',
                  startTime: new Date(date.getFullYear(), date.getMonth(), date.getDate(), startHour, startMinute),
                  endTime: new Date(date.getFullYear(), date.getMonth(), date.getDate(), endHour, endMinute),
                  userId: user.id,
                  projectId: projectId,
                  project,
                  priority: task.priority as 'P0' | 'P1' | 'P2' | 'P3',
                  status: task.status as any,
                  assignee: user,
                  color: getTaskColor(),
                  isRemote: false,
                  canMove: true,
                  canResize: !isMultiDay,
                  isSpanning: isMultiDay,
                  spanDay: isMultiDay ? dayIndex + 1 : undefined,
                  totalSpanDays: isMultiDay ? totalDays : undefined,
                  progress,
                  estimatedHours: task.estimatedHours,
                  daysRemaining: differenceInDays(taskEnd, new Date()),
                });
              }
            }
          });

              // Calculer la capacit√© utilisateur
              const capacity = await capacityService.calculateUserCapacity(user.id, {
                startDate: viewMode === 'week' ? currentPeriod.start : date,
                endDate: viewMode === 'week' ? currentPeriod.end : date,
              });

              // isRemoteWork sera calcul√© par le useMemo
              const isRemoteWork = false; // Valeur temporaire

              // Calculer utilisation pour ce jour
              const totalAllocated = calendarItems.reduce((sum, item) => {
                if (viewMode === 'week') {
                  return sum + differenceInHours(item.endTime, item.startTime);
                } else {
                  // En vue mensuelle, calculer seulement les heures de cette date
                  const itemStart = new Date(item.startTime);
                  const itemEnd = new Date(item.endTime);
                  if (isSameDay(itemStart, date)) {
                    return sum + Math.min(8, differenceInHours(itemEnd, itemStart)); // Max 8h par jour
                  }
                  return sum;
                }
              }, 0);

              // Calcul de charge supprim√©
              const utilizationRate = 0;

              // ‚úÖ Tri chronologique des t√¢ches par heure de d√©but
              calendarItems.sort((a, b) => a.startTime.getTime() - b.startTime.getTime());

              return {
                userId: user.id,
                user,
                date,
                capacity: 0,
                allocated: totalAllocated,
                items: calendarItems,
                isRemoteWork,
                utilizationRate,
                contract: await capacityService.getUserContract(user.id),
              } as UserWorkloadDay;

            } catch (error) {
              console.error(`Erreur pour utilisateur ${user.id} le ${format(date, 'dd/MM/yyyy')}:`, error);
              // isRemoteWork sera calcul√© par le useMemo m√™me en cas d'erreur
              const isRemoteWork = false; // Valeur temporaire

              return {
                userId: user.id,
                user,
                date,
                capacity: viewMode === 'week' ? 35 : 8,
                allocated: 0,
                items: [],
                isRemoteWork,
                utilizationRate: 0,
                contract: null,
              } as UserWorkloadDay;
            }
          });
        }
      }

      const workloadData = await Promise.all(workloadPromises.map(fn => fn()));
      
      // D√©tecter les conflits
      setRawWorkloadDays(workloadData);

    } catch (err) {
      console.error('Erreur lors du chargement:', err);
      setError('Erreur lors du chargement des donn√©es du calendrier');
    } finally {
      setLoading(false);
    }
  }, [currentDate, currentPeriod, selectedProjects, selectedUsers, viewMode]);



  // ========================================
  // DRAG & DROP HANDLERS
  // ========================================

  const handleItemMove = useCallback(async (
    itemId: string,
    newStartTime: Date,
    newEndTime: Date,
    newUserId?: string
  ) => {
    try {
      // Capturer l'√©tat pr√©c√©dent pour un rollback √©ventuel
      const previousState = workloadDays;
      
      // Trouver l'item original et ses d√©tails
      let originalItem: CalendarItem | null = null;
      let originalUserId: string | null = null;
      
      for (const userDay of workloadDays) {
        const item = userDay.items.find(i => i.id === itemId);
        if (item) {
          originalItem = item;
          originalUserId = userDay.userId;
          break;
        }
      }

      if (!originalItem || !originalUserId) {
        console.error('Item non trouv√©:', itemId);
        return;
      }

      // Mise √† jour optimiste de l'UI
      setRawWorkloadDays(prev => {
        const updated = [...prev];
        
        // Si on change d'utilisateur
        if (newUserId && newUserId !== originalUserId) {
          // Retirer de l'ancien utilisateur
          const oldUserIndex = updated.findIndex(u => u.userId === originalUserId);
          if (oldUserIndex !== -1) {
            updated[oldUserIndex] = {
              ...updated[oldUserIndex],
              items: updated[oldUserIndex].items.filter(item => item.id !== itemId),
              allocated: updated[oldUserIndex].allocated - differenceInHours(originalItem!.endTime, originalItem!.startTime),
            };
            // Calcul d'utilisation supprim√©
            updated[oldUserIndex].utilizationRate = 0;
          }
          
          // Ajouter au nouvel utilisateur
          const newUserIndex = updated.findIndex(u => u.userId === newUserId);
          if (newUserIndex !== -1 && originalItem) {
            const updatedItem: CalendarItem = {
              id: originalItem.id,
              title: originalItem.title,
              type: originalItem.type,
              startTime: newStartTime,
              endTime: newEndTime,
              userId: newUserId,
              projectId: originalItem.projectId,
              project: originalItem.project,
              priority: originalItem.priority,
              status: originalItem.status,
              assignee: users.find(u => u.id === newUserId),
              color: originalItem.color,
              isRemote: originalItem.isRemote,
              canMove: originalItem.canMove,
              canResize: originalItem.canResize,
            };
            updated[newUserIndex] = {
              ...updated[newUserIndex],
              items: [...updated[newUserIndex].items, updatedItem],
              allocated: updated[newUserIndex].allocated + differenceInHours(newEndTime, newStartTime),
            };
            // Calcul d'utilisation supprim√©
            updated[newUserIndex].utilizationRate = 0;
          }
        } else {
          // M√™me utilisateur, juste changer les dates
          const userIndex = updated.findIndex(u => u.userId === originalUserId);
          if (userIndex !== -1) {
            updated[userIndex] = {
              ...updated[userIndex],
              items: updated[userIndex].items.map(item => {
                if (item.id === itemId) {
                  return {
                    ...item,
                    startTime: newStartTime,
                    endTime: newEndTime,
                  };
                }
                return item;
              }),
            };
            // Recalculer l'allocation si les heures ont chang√©
            const oldDuration = differenceInHours(originalItem!.endTime, originalItem!.startTime);
            const newDuration = differenceInHours(newEndTime, newStartTime);
            if (oldDuration !== newDuration) {
              updated[userIndex].allocated = updated[userIndex].allocated - oldDuration + newDuration;
              updated[userIndex].utilizationRate = 0;
            }
          }
        }
        
        return updated;
      });

      // Persister en arri√®re-plan
      try {
        // D√©terminer l'ID de la t√¢che originale (pour les t√¢ches multi-jours)
        const taskId = originalItem.originalTaskId || originalItem.id;
        
        if (onTaskUpdate) {
          await onTaskUpdate(taskId, {
            startDate: newStartTime as any,
            dueDate: newEndTime as any,
            responsible: newUserId ? [newUserId] : [],
          });
        } else {
          // Si pas de callback, utiliser directement le service
          await taskService.updateTask(taskId, {
            startDate: newStartTime as any,
            dueDate: newEndTime as any,
            responsible: newUserId ? [newUserId] : [],
          });
        }
      } catch (error) {
        console.error('Erreur lors de la sauvegarde:', error);
        // Rollback en cas d'erreur
        setRawWorkloadDays(previousState);
        // Optionnel: afficher une notification d'erreur
        alert('Erreur lors du d√©placement de la t√¢che. Les modifications ont √©t√© annul√©es.');
      }
      
      // PAS de rechargement complet ! Les conflits seront recalcul√©s au prochain chargement
    } catch (error) {
      console.error('Erreur lors du d√©placement:', error);
    }
  }, [workloadDays, onTaskUpdate, users]);

  const handleItemDrop = useCallback((
    item: CalendarItem,
    userId: string,
    date: Date,
    slotIndex: number
  ) => {
    // Pour le moment, on garde la m√™me date mais on change l'assign√©
    const duration = differenceInHours(item.endTime, item.startTime);
    const newStartTime = date;
    const newEndTime = new Date(date.getTime() + duration * 60 * 60 * 1000);

    handleItemMove(item.id, newStartTime, newEndTime, userId);
  }, [handleItemMove]);

  const handleCreateTask = useCallback((userId: string, date: Date) => {
    // Si des projets sont s√©lectionn√©s, prendre le premier, sinon laisser vide (non affect√©)
    const defaultProject = selectedProjects.length > 0 
      ? projects.find(p => selectedProjects.includes(p.id))
      : null;
    
    setTaskModalData({
      userId,
      date,
      projectId: defaultProject?.id || '', // Vide = non affect√©
      task: null,
    });
    setTaskModalOpen(true);
  }, [projects, selectedProjects]);

  const handleTaskSave = useCallback(async (task: Task) => {
    try {
      if (task.id) {
        await taskService.updateTask(task.id, task);
      } else {
        // Cr√©er des dates avec des heures pour √©viter les probl√®mes de filtrage si pas de dueDate d√©finie
        let finalDueDate = task.dueDate;
        let finalStartDate = task.startDate || task.dueDate;
        
        if (!finalDueDate && taskModalData.date) {
          const taskDate = new Date(taskModalData.date);
          finalStartDate = new Date(taskDate.getFullYear(), taskDate.getMonth(), taskDate.getDate(), 9, 0);
          finalDueDate = new Date(taskDate.getFullYear(), taskDate.getMonth(), taskDate.getDate(), 17, 0);
        }
        
        await taskService.createTask({
          ...task,
          responsible: taskModalData.userId ? [taskModalData.userId] : [],
          startDate: finalStartDate as any,
          dueDate: finalDueDate as any,
          projectId: task.projectId || taskModalData.projectId || '',
        });
      }
      
      // Recharger les donn√©es
      await loadCalendarData();
      setTaskModalOpen(false);
      setTaskModalData({});
    } catch (error) {
      console.error('Erreur lors de la sauvegarde de la t√¢che:', error);
    }
  }, [taskModalData, loadCalendarData]);

  // ========================================
  // TELEWORK HANDLERS V2
  // ========================================

  const handleTeleworkModeChange = useCallback(async (userId: string, date: Date, mode: 'office' | 'remote') => {
    try {
      await teleworkSystem.requestOverride(userId, date, mode, 'Demande depuis planning');
      // Force refresh
      await teleworkSystem.refreshData();
    } catch (error) {
      console.error('‚ùå Erreur changement mode t√©l√©travail:', error);
      alert('Erreur lors de la d√©claration de t√©l√©travail: ' + (error as Error).message);
    }
  }, [teleworkSystem]);

  const handleTeleworkProfileConfig = useCallback((userId: string) => {
    teleworkSystem.openProfileModal(userId);
  }, [teleworkSystem]);

  const handleTeleworkDetails = useCallback((userId: string, date: Date) => {
    teleworkSystem.openStatsModal(userId);
  }, [teleworkSystem]);

  const handleTaskDelete = useCallback(async (taskId: string) => {
    const taskToDelete = selectedItem || workloadDays.flatMap(w => w.items).find(item => item.id === taskId);

    if (!taskToDelete) {
      console.error('T√¢che √† supprimer introuvable:', taskId);
      return;
    }

    // D√©terminer l'ID de la t√¢che originale (pour les t√¢ches multi-jours)
    const originalTaskId = taskToDelete.originalTaskId || taskId;

    const confirmDelete = window.confirm(
      `√ätes-vous s√ªr de vouloir supprimer d√©finitivement la t√¢che "${taskToDelete.title}" ?\n\nCette action est irr√©versible.`
    );

    if (!confirmDelete) return;

    try {
      // Utiliser le bon service selon le type de t√¢che
      if (taskToDelete.type === 'simple_task') {
        console.log('üóëÔ∏è Suppression t√¢che simple:', originalTaskId);
        await simpleTaskService.delete(originalTaskId);
      } else {
        console.log('üóëÔ∏è Suppression t√¢che projet:', originalTaskId);
        await taskService.deleteTask(originalTaskId);
      }

      // Recharger les donn√©es
      await loadCalendarData();

      // Fermer toutes les modals
      setTaskModalOpen(false);
      setTaskModalData({});
      setSelectedItem(null);
    } catch (error) {
      console.error('Erreur lors de la suppression de la t√¢che:', error);
      alert('Erreur lors de la suppression de la t√¢che');
    }
  }, [loadCalendarData, selectedItem, workloadDays]);

  const handleEditTask = useCallback(async (calendarItem: CalendarItem) => {
    // D√©terminer l'ID de la t√¢che originale (pour les t√¢ches multi-jours)
    const taskId = calendarItem.originalTaskId || calendarItem.id;
    const isSimpleTask = calendarItem.type === 'simple_task';

    // Fermer la modal g√©n√©rique
    setSelectedItem(null);

    try {
      let task = null;

      if (isSimpleTask) {
        // Pour les t√¢ches simples, utiliser simpleTaskService
        console.log('Chargement t√¢che simple:', taskId);
        task = await simpleTaskService.getById(taskId);
      } else {
        // Pour les t√¢ches de projet, utiliser taskService
        console.log('Chargement t√¢che projet:', taskId);
        task = await taskService.getTask(taskId);
      }

      if (task) {
        console.log('T√¢che charg√©e avec succ√®s:', task);

        // Convertir SimpleTask en Task si n√©cessaire
        let taskForModal = task;
        if (isSimpleTask && task) {
          const st = task as any;
          taskForModal = {
            id: st.id,
            title: st.title,
            description: st.description,
            projectId: '',
            taskCategory: 'SIMPLE_TASK',
            priority: st.priority,
            status: st.status,
            type: 'TASK',
            dueDate: st.date,
            startDate: st.date,
            startTime: st.timeSlot.start,
            endTime: st.timeSlot.end,
            responsible: [st.assignedTo],
            createdBy: st.createdBy,
            createdAt: st.createdAt,
            updatedAt: st.updatedAt,
            dependencies: [],
            labels: [],
            attachments: [],
            comments: [],
          } as any;
        }

        setTaskModalData({
          userId: calendarItem.userId,
          date: calendarItem.startTime,
          projectId: calendarItem.projectId,
          task: taskForModal as any,
        });
        setTaskModalOpen(true);
      } else {
        console.error('T√¢che non trouv√©e:', taskId);
        alert('T√¢che non trouv√©e');
      }
    } catch (error) {
      console.error('Erreur lors du chargement de la t√¢che:', error);
      alert('Erreur lors du chargement de la t√¢che');
    }
  }, []);

  // ========================================
  // NAVIGATION
  // ========================================

  const handlePrevious = () => {
    if (viewMode === 'week') {
      setCurrentDate(subWeeks(currentDate, 1));
    } else {
      setCurrentDate(subMonths(currentDate, 1));
    }
  };

  const handleNext = () => {
    if (viewMode === 'week') {
      setCurrentDate(addWeeks(currentDate, 1));
    } else {
      setCurrentDate(addMonths(currentDate, 1));
    }
  };

  const handleToday = () => {
    setCurrentDate(new Date());
  };

  // ========================================
  // EFFECTS
  // ========================================

  useEffect(() => {
    loadCalendarData();
  }, [loadCalendarData]);

  // ========================================
  // RENDER
  // ========================================

  if (loading) {
    return (
      <Box display="flex" justifyContent="center" p={4}>
        <Stack alignItems="center">
          <CircularProgress />
          <Typography>Chargement du planning intelligent...</Typography>
        </Stack>
      </Box>
    );
  }

  if (error) {
    return (
      <Alert severity="error" sx={{ m: 2 }}>
        {error}
        <Button onClick={loadCalendarData} sx={{ ml: 2 }}>
          R√©essayer
        </Button>
      </Alert>
    );
  }

  const getViewTitle = () => {
    if (viewMode === 'week') {
      const firstDay = weekDays[0];
      const lastDay = weekDays[weekDays.length - 1];
      return `Semaine du ${format(firstDay, 'd MMM', { locale: fr })} au ${format(lastDay, 'd MMM yyyy', { locale: fr })}`;
    } else {
      return format(currentDate, 'MMMM yyyy', { locale: fr });
    }
  };

  return (
    <DndProvider backend={HTML5Backend}>
      <Box>
        {/* Header avec navigation et stats */}
        <Card sx={{ mb: 2 }}>
          <CardContent>
            <Stack direction="row" justifyContent="space-between" alignItems="center" mb={2}>
              <Typography variant="h4">
                üìÖ Planning
              </Typography>
              
              {/* Stats globales */}
              <Stack direction="row">
                <Chip
                  icon={<PersonIcon />}
                  label={`${users.length} ressources`}
                  color="primary"
                />
              </Stack>
            </Stack>

            {/* Navigation */}
            <Stack direction="row" justifyContent="space-between" alignItems="center">
              <Stack direction="row" alignItems="center">
                <IconButton onClick={handlePrevious}>
                  <ChevronLeftIcon />
                </IconButton>
                
                <Button variant="outlined" startIcon={<TodayIcon />} onClick={handleToday}>
                  Aujourd'hui
                </Button>
                
                <IconButton onClick={handleNext}>
                  <ChevronRightIcon />
                </IconButton>
                
                <Typography variant="h6" sx={{ ml: 2, textTransform: 'capitalize' }}>
                  {getViewTitle()}
                </Typography>
              </Stack>

              {/* S√©lecteur de vue */}
              <Stack direction="row">
                <FormControl size="small">
                  <Select
                    value={viewMode}
                    onChange={(e) => setViewMode(e.target.value as ViewMode)}
                  >
                    <MenuItem value="week">
                      <Stack direction="row" alignItems="center">
                        <ViewWeekIcon fontSize="small" />
                        <span>Semaine</span>
                      </Stack>
                    </MenuItem>
                    <MenuItem value="month">
                      <Stack direction="row" alignItems="center">
                        <CalendarMonthIcon fontSize="small" />
                        <span>Mois</span>
                      </Stack>
                    </MenuItem>
                  </Select>
                </FormControl>
              </Stack>
            </Stack>
          </CardContent>
        </Card>


        {/* En-t√™tes des colonnes jours */}
        {viewMode === 'week' && (
          <Card sx={{ 
            mb: 1, 
            position: 'sticky', 
            top: 64, // Hauteur approximative de la navbar Material-UI
            zIndex: 1000, 
            backgroundColor: 'background.paper',
            boxShadow: 2
          }}>
            <CardContent sx={{ p: 1 }}>
              <Box sx={{ display: "flex", alignItems: "center", gap: 1 }}>
                {/* Zone utilisateur header - m√™me largeur que les lignes */}
                <Box sx={{ 
                  width: 240, 
                  minWidth: 240,
                  maxWidth: 240,
                  flexShrink: 0,
                  borderRight: '1px solid',
                  borderColor: 'divider',
                  pr: 1
                }}>
                  <Typography variant="body2" fontWeight="bold" color="text.secondary">
                    Ressources
                  </Typography>
                </Box>
                
                {/* Zone des jours - m√™me structure que les lignes */}
                <Box sx={{ 
                  flex: 1,
                  minWidth: 0,
                  overflowX: 'auto'
                }}>
                  <Stack direction="row" spacing={0.5}>
                    {weekDays.map((day) => (
                      <Box 
                        key={day.toISOString()} 
                        sx={{ 
                          width: 160,
                          minWidth: 160,
                          maxWidth: 160,
                          textAlign: 'center',
                          p: 0.5,
                          borderRadius: 1,
                          backgroundColor: isToday(day) ? 'primary.light' : 'transparent'
                        }}
                      >
                        <Typography 
                          variant="body2" 
                          fontWeight="bold"
                          color={isToday(day) ? 'primary.main' : 'text.primary'}
                          sx={{ fontSize: '0.8rem' }}
                        >
                          {format(day, 'EEE d MMM', { locale: fr })}
                        </Typography>
                        {isToday(day) && (
                          <Typography variant="caption" color="primary" sx={{ fontSize: '0.7rem' }}>
                            Aujourd'hui
                          </Typography>
                        )}
                      </Box>
                    ))}
                  </Stack>
                </Box>
              </Box>
            </CardContent>
          </Card>
        )}

        {/* Rendu conditionnel selon la vue */}
        {viewMode === 'week' ? (
          /* Vue hebdomadaire - Planning d√©taill√© group√© par service */
          <Stack>
            {Array.from(workloadDaysByService.entries()).map(([serviceId, serviceWorkloadDays]) => {
              // Gestion sp√©ciale pour "Encadrement"
              if (serviceId === 'encadrement') {
                const serviceName = 'Encadrement';
                const serviceColor = '#ff9800'; // Orange pour l'encadrement
                const isExpanded = expandedServices.has(serviceId);
                const userCount = serviceWorkloadDays.length;
                
                return (
                  <Box key={serviceId}>
                    {/* En-t√™te du service Encadrement */}
                    <Card 
                      sx={{ 
                        mb: 0.5,
                        background: 'linear-gradient(90deg, rgba(255,152,0,0.1) 0%, rgba(255,152,0,0.05) 100%)',
                        border: '1px solid rgba(255,152,0,0.2)'
                      }}
                    >
                      <CardContent sx={{ p: 1.5, '&:last-child': { pb: 1.5 } }}>
                        <Stack 
                          direction="row" 
                          alignItems="center" 
                         
                          sx={{ cursor: 'pointer' }}
                          onClick={() => toggleService(serviceId)}
                        >
                          <Box 
                            sx={{ 
                              width: 12, 
                              height: 12, 
                              borderRadius: '50%', 
                              bgcolor: serviceColor
                            }} 
                          />
                          <BusinessIcon sx={{ color: 'warning.main' }} />
                          <Typography variant="h6" fontWeight="bold" color="warning.main">
                            {serviceName}
                          </Typography>
                          <Chip 
                            label={`${userCount} ressource${userCount > 1 ? 's' : ''}`}
                            size="small" 
                            color="warning" 
                            variant="outlined"
                          />
                          <Box flexGrow={1} />
                          <IconButton size="small">
                            {isExpanded ? <ExpandLessIcon /> : <ExpandMoreIcon />}
                          </IconButton>
                        </Stack>
                      </CardContent>
                    </Card>

                    {/* Liste des utilisateurs de l'encadrement */}
                    <Collapse in={isExpanded}>
                      <Box sx={{ ml: 2, mb: 1 }}>
                        <Stack spacing={0.5}>
                          {serviceWorkloadDays.map((workloadDay) => (
                            <UserRow
                              key={workloadDay.userId}
                              workloadDay={workloadDay}
                              viewMode={viewMode}
                              weekDays={weekDays}
                              departments={departments}
                              userContracts={userContracts}
                              currentUserId={auth.currentUser?.uid || ''}
                              teleworkSystem={teleworkSystem}
                              onItemMove={handleItemMove}
                              onItemClick={setSelectedItem}
                              onItemDrop={handleItemDrop}
                              onCreateTask={handleCreateTask}
                              onTeleworkModeChange={handleTeleworkModeChange}
                              onTeleworkProfileConfig={handleTeleworkProfileConfig}
                              onTeleworkDetails={handleTeleworkDetails}
                            />
                          ))}
                        </Stack>
                      </Box>
                    </Collapse>
                  </Box>
                );
              }

              // Gestion normale pour les autres services
              const service = services.find(s => s.id === serviceId);
              const serviceName = service?.name || (serviceId === 'no-service' ? 'Sans service' : serviceId);
              const serviceColor = service?.color || 'grey.400';
              const isExpanded = expandedServices.has(serviceId);
              const userCount = serviceWorkloadDays.length;

              return (
                <Box key={serviceId}>
                  {/* En-t√™te du service */}
                  <Card 
                    sx={{ 
                      mb: 0.5,
                      background: 'linear-gradient(90deg, rgba(76,175,80,0.1) 0%, rgba(76,175,80,0.05) 100%)',
                      border: '1px solid rgba(76,175,80,0.2)'
                    }}
                  >
                    <CardContent sx={{ p: 1.5, '&:last-child': { pb: 1.5 } }}>
                      <Stack 
                        direction="row" 
                        alignItems="center" 
                       
                        sx={{ cursor: 'pointer' }}
                        onClick={() => toggleService(serviceId)}
                      >
                        <Box 
                          sx={{ 
                            width: 12, 
                            height: 12, 
                            borderRadius: '50%', 
                            bgcolor: serviceColor
                          }} 
                        />
                        <WorkIcon sx={{ color: 'success.main' }} />
                        <Typography variant="h6" fontWeight="bold" color="success.main">
                          {serviceName}
                        </Typography>
                        <Chip 
                          label={`${userCount} ressource${userCount > 1 ? 's' : ''}`}
                          size="small" 
                          color="success" 
                          variant="outlined"
                        />
                        <Box flexGrow={1} />
                        <IconButton size="small">
                          {isExpanded ? <ExpandLessIcon /> : <ExpandMoreIcon />}
                        </IconButton>
                      </Stack>
                    </CardContent>
                  </Card>

                  {/* Liste des utilisateurs du service */}
                  <Collapse in={isExpanded}>
                    <Box sx={{ ml: 2, mb: 1 }}>
                      <Stack spacing={0.5}>
                        {serviceWorkloadDays.map((workloadDay) => (
                          <UserRow
                            key={workloadDay.userId}
                            workloadDay={workloadDay}
                            viewMode={viewMode}
                            weekDays={weekDays}
                            departments={departments}
                            userContracts={userContracts}
                            currentUserId={auth.currentUser?.uid || ''}
                            teleworkSystem={teleworkSystem}
                            onItemMove={handleItemMove}
                            onItemClick={setSelectedItem}
                            onItemDrop={handleItemDrop}
                            onCreateTask={handleCreateTask}
                            onTeleworkModeChange={handleTeleworkModeChange}
                            onTeleworkProfileConfig={handleTeleworkProfileConfig}
                            onTeleworkDetails={handleTeleworkDetails}
                          />
                        ))}
                      </Stack>
                    </Box>
                  </Collapse>
                </Box>
              );
            })}
          </Stack>
        ) : (
          /* Vue mensuelle - Planning d√©taill√© mensuel */
          <>
            {/* En-t√™tes des colonnes jours du mois */}
            <Card sx={{ 
              mb: 1, 
              position: 'sticky', 
              top: 64,
              zIndex: 1000, 
              backgroundColor: 'background.paper',
              boxShadow: 2
            }}>
              <CardContent sx={{ p: 1 }}>
                <Box sx={{ display: "flex", gap: 2, flexWrap: "wrap" }}>
                  <Box sx={{ flexGrow: 1, minWidth: 200 }}>
                    <Typography variant="body2" fontWeight="bold" color="text.secondary">
                      Ressources
                    </Typography>
                  </Box>
                  <Box sx={{ flexGrow: 1, minWidth: 200 }}>
                    <Box sx={{ overflowX: 'auto', pb: 1 }}>
                      <Stack direction="row" spacing={0.5}>
                        {(() => {
                          const monthStart = startOfMonth(currentDate);
                          const monthEnd = endOfMonth(currentDate);
                          const monthDays = [];
                          let date = monthStart;
                          while (date <= monthEnd) {
                            monthDays.push(new Date(date));
                            date = addDays(date, 1);
                          }
                          return monthDays.map((day) => (
                            <Box key={day.toISOString()} sx={{ minWidth: 60, textAlign: 'center' }}>
                              <Typography 
                                variant="caption" 
                                fontWeight="bold"
                                color={isToday(day) ? 'primary.main' : 'text.primary'}
                                display="block"
                              >
                                {format(day, 'EEE', { locale: fr })}
                              </Typography>
                              <Typography 
                                variant="body2" 
                                fontWeight={isToday(day) ? 'bold' : 'normal'}
                                color={isToday(day) ? 'primary.main' : 'text.primary'}
                              >
                                {format(day, 'd')}
                              </Typography>
                            </Box>
                          ));
                        })()}
                      </Stack>
                    </Box>
                  </Box>
                </Box>
              </CardContent>
            </Card>

            {/* Planning mensuel d√©taill√© group√© par service */}
            <Stack>
              {Array.from(workloadDaysByService.entries()).map(([serviceId, serviceWorkloadDays]) => {
                // Gestion sp√©ciale pour "Encadrement"
                if (serviceId === 'encadrement') {
                  const serviceName = 'Encadrement';
                  const serviceColor = '#ff9800';
                  const isExpanded = expandedServices.has(serviceId);
                  const userCount = serviceWorkloadDays.length;
                  
                  return (
                    <Box key={serviceId}>
                      {/* En-t√™te du service Encadrement */}
                      <Card 
                        sx={{ 
                          mb: 0.5,
                          background: 'linear-gradient(90deg, rgba(255,152,0,0.1) 0%, rgba(255,152,0,0.05) 100%)',
                          border: '1px solid rgba(255,152,0,0.2)'
                        }}
                      >
                        <CardContent sx={{ p: 1.5, '&:last-child': { pb: 1.5 } }}>
                          <Stack 
                            direction="row" 
                            alignItems="center" 
                           
                            sx={{ cursor: 'pointer' }}
                            onClick={() => toggleService(serviceId)}
                          >
                            <Box 
                              sx={{ 
                                width: 12, 
                                height: 12, 
                                borderRadius: '50%', 
                                bgcolor: serviceColor
                              }} 
                            />
                            <BusinessIcon sx={{ color: 'warning.main' }} />
                            <Typography variant="h6" fontWeight="bold" color="warning.main">
                              {serviceName}
                            </Typography>
                            <Chip 
                              label={`${userCount} ressource${userCount > 1 ? 's' : ''}`}
                              size="small" 
                              color="warning" 
                              variant="outlined"
                            />
                            <Box flexGrow={1} />
                            <IconButton size="small">
                              {isExpanded ? <ExpandLessIcon /> : <ExpandMoreIcon />}
                            </IconButton>
                          </Stack>
                        </CardContent>
                      </Card>

                      {/* Liste des utilisateurs de l'encadrement - Vue mensuelle */}
                      <Collapse in={isExpanded}>
                        <Box sx={{ ml: 2, mb: 1 }}>
                          <Stack spacing={0.5}>
                            {serviceWorkloadDays.map((workloadDay) => {
                              const monthStart = startOfMonth(currentDate);
                              const monthEnd = endOfMonth(currentDate);
                              const monthDays = [];
                              let date = monthStart;
                              while (date <= monthEnd) {
                                monthDays.push(new Date(date));
                                date = addDays(date, 1);
                              }

                              return (
                                <Card key={workloadDay.userId} sx={{ mb: 1 }}>
                                  <CardContent sx={{ p: 1 }}>
                                    <Box sx={{ display: "flex", gap: 2, flexWrap: "wrap" }}>
                                      {/* Colonne utilisateur avec m√©triques */}
                                      <Box sx={{ flexGrow: 1, minWidth: 200 }}>
                                        <Stack direction="row" alignItems="center">
                                          <Avatar 
                                            src={workloadDay.user.avatarUrl} 
                                            sx={{ width: 28, height: 28 }}
                                          >
                                            {workloadDay.user.firstName?.[0]}{workloadDay.user.lastName?.[0]}
                                          </Avatar>
                                          
                                          <Box flexGrow={1}>
                                            <Typography variant="caption" fontWeight="bold">
                                              {getUserDisplayName(workloadDay.user)}
                                            </Typography>
                                          </Box>
                                        </Stack>
                                      </Box>

                                      {/* Colonnes des jours du mois */}
                                      <Box sx={{ flexGrow: 1, minWidth: 200 }}>
                                        <Box sx={{ overflowX: 'auto' }}>
                                          <Stack direction="row" spacing={0.5}>
                                            {monthDays.map((day) => {
                                              const dayItems = workloadDay.items.filter(item => 
                                                isSameDay(item.startTime, day)
                                              );
                                              
                                              return (
                                                <Box key={day.toISOString()} sx={{ minWidth: 60, height: 50 }}>
                                                  {dayItems.length > 0 ? (
                                                    <Stack spacing={0.2}>
                                                      {dayItems.slice(0, 2).map((item, index) => (
                                                        <Box
                                                          key={item.id}
                                                          sx={{
                                                            bgcolor: item.color || '#2196f3',
                                                            color: 'white',
                                                            borderRadius: 0.5,
                                                            p: 0.2,
                                                            fontSize: '0.6rem',
                                                            textAlign: 'center',
                                                            cursor: 'pointer',
                                                            '&:hover': { opacity: 0.8 }
                                                          }}
                                                          onClick={() => setSelectedItem(item)}
                                                        >
                                                          <Typography variant="caption" sx={{ fontSize: '0.5rem' }}>
                                                            {item.title.substring(0, 8)}...
                                                          </Typography>
                                                          {item.type === 'simple_task' && item.startTimeString && item.endTimeString && (
                                                            <Typography variant="caption" sx={{ fontSize: '0.45rem', display: 'block', fontWeight: 'bold' }}>
                                                              üïê {item.startTimeString}-{item.endTimeString}
                                                            </Typography>
                                                          )}
                                                        </Box>
                                                      ))}
                                                      {dayItems.length > 2 && (
                                                        <Typography variant="caption" sx={{ fontSize: '0.5rem', textAlign: 'center' }}>
                                                          +{dayItems.length - 2}
                                                        </Typography>
                                                      )}
                                                    </Stack>
                                                  ) : (
                                                    <Box 
                                                      sx={{ 
                                                        height: 40, 
                                                        border: '1px dashed transparent',
                                                        borderRadius: 0.5,
                                                        cursor: 'pointer',
                                                        '&:hover': {
                                                          borderColor: 'primary.main',
                                                          bgcolor: 'grey.50'
                                                        }
                                                      }}
                                                      onClick={() => handleCreateTask(workloadDay.userId, day)}
                                                    />
                                                  )}
                                                </Box>
                                              );
                                            })}
                                          </Stack>
                                        </Box>
                                      </Box>
                                    </Box>
                                  </CardContent>
                                </Card>
                              );
                            })}
                          </Stack>
                        </Box>
                      </Collapse>
                    </Box>
                  );
                }

                // Gestion normale pour les autres services
                const service = services.find(s => s.id === serviceId);
                const serviceName = service?.name || (serviceId === 'no-service' ? 'Sans service' : serviceId);
                const serviceColor = service?.color || 'grey.400';
                const isExpanded = expandedServices.has(serviceId);
                const userCount = serviceWorkloadDays.length;

                return (
                  <Box key={serviceId}>
                    {/* En-t√™te du service */}
                    <Card 
                      sx={{ 
                        mb: 0.5,
                        background: 'linear-gradient(90deg, rgba(76,175,80,0.1) 0%, rgba(76,175,80,0.05) 100%)',
                        border: '1px solid rgba(76,175,80,0.2)'
                      }}
                    >
                      <CardContent sx={{ p: 1.5, '&:last-child': { pb: 1.5 } }}>
                        <Stack 
                          direction="row" 
                          alignItems="center" 
                         
                          sx={{ cursor: 'pointer' }}
                          onClick={() => toggleService(serviceId)}
                        >
                          <Box 
                            sx={{ 
                              width: 12, 
                              height: 12, 
                              borderRadius: '50%', 
                              bgcolor: serviceColor
                            }} 
                          />
                          <WorkIcon sx={{ color: 'success.main' }} />
                          <Typography variant="h6" fontWeight="bold" color="success.main">
                            {serviceName}
                          </Typography>
                          <Chip 
                            label={`${userCount} ressource${userCount > 1 ? 's' : ''}`}
                            size="small" 
                            color="success" 
                            variant="outlined"
                          />
                          <Box flexGrow={1} />
                          <IconButton size="small">
                            {isExpanded ? <ExpandLessIcon /> : <ExpandMoreIcon />}
                          </IconButton>
                        </Stack>
                      </CardContent>
                    </Card>

                    {/* Liste des utilisateurs du service - Vue mensuelle */}
                    <Collapse in={isExpanded}>
                      <Box sx={{ ml: 2, mb: 1 }}>
                        <Stack spacing={0.5}>
                          {serviceWorkloadDays.map((workloadDay) => {
                            const monthStart = startOfMonth(currentDate);
                            const monthEnd = endOfMonth(currentDate);
                            const monthDays = [];
                            let date = monthStart;
                            while (date <= monthEnd) {
                              monthDays.push(new Date(date));
                              date = addDays(date, 1);
                            }

                            return (
                              <Card key={workloadDay.userId} sx={{ mb: 1 }}>
                                <CardContent sx={{ p: 1 }}>
                                  <Box sx={{ display: "flex", gap: 2, flexWrap: "wrap" }}>
                                    {/* Colonne utilisateur avec m√©triques */}
                                    <Box sx={{ flexGrow: 1, minWidth: 200 }}>
                                      <Stack direction="row" alignItems="center">
                                        <Avatar 
                                          src={workloadDay.user.avatarUrl} 
                                          sx={{ width: 28, height: 28 }}
                                        >
                                          {workloadDay.user.firstName?.[0]}{workloadDay.user.lastName?.[0]}
                                        </Avatar>
                                        
                                        <Box flexGrow={1}>
                                          <Typography variant="caption" fontWeight="bold">
                                            {getUserDisplayName(workloadDay.user)}
                                          </Typography>
                                        </Box>
                                      </Stack>
                                    </Box>

                                    {/* Colonnes des jours du mois */}
                                    <Box sx={{ flexGrow: 1, minWidth: 200 }}>
                                      <Box sx={{ overflowX: 'auto' }}>
                                        <Stack direction="row" spacing={0.5}>
                                          {monthDays.map((day) => {
                                            const dayItems = workloadDay.items.filter(item => 
                                              isSameDay(item.startTime, day)
                                            );
                                            
                                            return (
                                              <Box key={day.toISOString()} sx={{ minWidth: 60, minHeight: 40 }}>
                                                {dayItems.length > 0 ? (
                                                  <Stack spacing={0.2}>
                                                    {dayItems.slice(0, 2).map((item, index) => (
                                                      <Box
                                                        key={item.id}
                                                        sx={{
                                                          bgcolor: item.color || '#2196f3',
                                                          color: 'white',
                                                          borderRadius: 0.5,
                                                          p: 0.2,
                                                          fontSize: '0.6rem',
                                                          textAlign: 'center',
                                                          cursor: 'pointer',
                                                          '&:hover': { opacity: 0.8 }
                                                        }}
                                                        onClick={() => setSelectedItem(item)}
                                                      >
                                                        <Typography variant="caption" sx={{ fontSize: '0.5rem' }}>
                                                          {item.title.substring(0, 8)}...
                                                        </Typography>
                                                      </Box>
                                                    ))}
                                                    {dayItems.length > 2 && (
                                                      <Typography variant="caption" sx={{ fontSize: '0.5rem', textAlign: 'center' }}>
                                                        +{dayItems.length - 2}
                                                      </Typography>
                                                    )}
                                                  </Stack>
                                                ) : (
                                                  <Box 
                                                    sx={{ 
                                                      minHeight: 40, 
                                                      border: '1px dashed transparent',
                                                      borderRadius: 0.5,
                                                      cursor: 'pointer',
                                                      '&:hover': {
                                                        borderColor: 'primary.main',
                                                        bgcolor: 'grey.50'
                                                      }
                                                    }}
                                                    onClick={() => handleCreateTask(workloadDay.userId, day)}
                                                  />
                                                )}
                                              </Box>
                                            );
                                          })}
                                        </Stack>
                                      </Box>
                                    </Box>
                                  </Box>
                                </CardContent>
                              </Card>
                            );
                          })}
                        </Stack>
                      </Box>
                    </Collapse>
                  </Box>
                );
              })}
            </Stack>
          </>
        )}


        {/* Dialog d√©tail item */}
        <Dialog
          open={!!selectedItem}
          onClose={() => setSelectedItem(null)}
          maxWidth="md"
          fullWidth
        >
          <DialogTitle>
            üìã D√©tail de l'activit√©
          </DialogTitle>
          <DialogContent>
            {selectedItem && (
              <Stack>
                <Box>
                  <Typography variant="h6">{selectedItem.title}</Typography>
                  <Typography variant="body2" color="text.secondary">
                    {selectedItem.project?.name || 'Non affect√© (Admin/Formation)'}
                  </Typography>
                </Box>
                
                <Divider />
                
                <Stack direction="row">
                  <Box>
                    <Typography variant="subtitle2" gutterBottom>Horaires</Typography>
                    <Typography variant="body2">
                      {format(selectedItem.startTime, 'dd/MM/yyyy HH:mm', { locale: fr })}
                      {' ‚Üí '}
                      {format(selectedItem.endTime, 'dd/MM/yyyy HH:mm', { locale: fr })}
                    </Typography>
                    <Typography variant="caption" color="text.secondary">
                      Dur√©e: {differenceInHours(selectedItem.endTime, selectedItem.startTime)}h
                    </Typography>
                  </Box>
                  
                  <Box>
                    <Typography variant="subtitle2" gutterBottom>Assign√© √†</Typography>
                    <Stack direction="row" alignItems="center">
                      <Avatar 
                        src={selectedItem.assignee?.avatarUrl} 
                        sx={{ width: 24, height: 24 }}
                      >
                        {selectedItem.assignee?.firstName?.[0]}{selectedItem.assignee?.lastName?.[0]}
                      </Avatar>
                      <Typography variant="body2">
                        {selectedItem.assignee ? getUserDisplayName(selectedItem.assignee) : 'Non assign√©'}
                      </Typography>
                    </Stack>
                  </Box>
                </Stack>

                <Stack direction="row">
                  <Chip
                    label={selectedItem.type.toUpperCase()}
                    size="small"
                    color="primary"
                  />
                  <Chip
                    label={selectedItem.priority}
                    size="small"
                    color={selectedItem.priority === 'P0' ? 'error' : 'default'}
                  />
                  <Chip
                    label={selectedItem.status}
                    size="small"
                    color={selectedItem.status === 'DONE' ? 'success' : 'default'}
                  />
                  {selectedItem.isRemote && (
                    <Chip
                      label="T√©l√©travail"
                      size="small"
                      icon={<HomeIcon />}
                      color="secondary"
                    />
                  )}
                </Stack>

              </Stack>
            )}
          </DialogContent>
          <DialogActions sx={{ justifyContent: 'space-between' }}>
            <Button 
              color="error"
              startIcon={<DeleteIcon />}
              onClick={() => selectedItem && handleTaskDelete(selectedItem.id)}
              variant="outlined"
            >
              Supprimer
            </Button>
            <Box sx={{ display: 'flex', gap: 1 }}>
              <Button onClick={() => setSelectedItem(null)}>
                Fermer
              </Button>
              <Button 
                variant="contained"
                onClick={() => selectedItem && handleEditTask(selectedItem)}
              >
                Modifier
              </Button>
            </Box>
          </DialogActions>
        </Dialog>

        {/* TaskModal pour cr√©er/√©diter des t√¢ches */}
        <TaskModal
          open={taskModalOpen}
          onClose={() => {
            setTaskModalOpen(false);
            setTaskModalData({});
          }}
          task={taskModalData.task}
          projectId={taskModalData.projectId}
          dueDate={taskModalData.date}
          onSave={handleTaskSave}
          onDelete={handleTaskDelete}
        />

        {/* Modal de configuration profil t√©l√©travail */}
        <TeleworkProfileModal
          isOpen={teleworkSystem.modalState.isOpen && teleworkSystem.modalState.mode === 'profile'}
          userId={teleworkSystem.modalState.targetUserId || ''}
          currentProfile={teleworkSystem.modalState.data}
          onClose={teleworkSystem.closeModal}
          onSave={(profile) => {
            if (teleworkSystem.modalState.targetUserId) {
              teleworkSystem.updateProfile(teleworkSystem.modalState.targetUserId, profile);
            }
            teleworkSystem.closeModal();
          }}
        />
      </Box>
    </DndProvider>
  );
};

export default PlanningCalendar;