import React, { useState, useEffect } from 'react';
import {
  Card,
  CardContent,
  TextField,
  InputAdornment,
  FormControl,
  InputLabel,
  Select,
  MenuItem,
  Chip,
  Box,
  Grid,
  Button,
  Collapse,
  Typography,
  Autocomplete,
  FormControlLabel,
  Checkbox,
  Slider,
  Accordion,
  AccordionSummary,
  AccordionDetails,
  Badge,
} from '@mui/material';
import {
  Search as SearchIcon,
  FilterList as FilterIcon,
  Clear as ClearIcon,
  ExpandMore as ExpandMoreIcon,
  CalendarToday as CalendarIcon,
  Person as PersonIcon,
  Flag as FlagIcon,
} from '@mui/icons-material';
import { TaskStatus, Priority, TaskType, User, Project } from '../../types';

interface TaskFiltersProps {
  onFiltersChange: (filters: TaskFilterState) => void;
  users?: User[];
  projects?: Project[];
  availableLabels?: string[];
}

export interface TaskFilterState {
  searchTerm: string;
  status: TaskStatus[];
  priority: Priority[];
  type: TaskType[];
  assigneeIds: string[];
  projectIds: string[];
  labels: string[];
  isBlocked?: boolean;
  technicalDebt?: boolean;
  dueDateRange: {
    from?: Date;
    to?: Date;
  };
  estimationRange: {
    min?: number;
    max?: number;
  };
  businessValueRange: {
    min?: number;
    max?: number;
  };
  riskLevel: string[];
  hasAttachments?: boolean;
  hasComments?: boolean;
}

const initialFilters: TaskFilterState = {
  searchTerm: '',
  status: [],
  priority: [],
  type: [],
  assigneeIds: [],
  projectIds: [],
  labels: [],
  dueDateRange: {},
  estimationRange: {},
  businessValueRange: {},
  riskLevel: [],
};

const TASK_STATUSES = [
  { value: 'TODO', label: '√Ä faire', color: '#2196f3' },
  { value: 'IN_PROGRESS', label: 'En cours', color: '#ff9800' },
  { value: 'DONE', label: 'Termin√©', color: '#4caf50' },
  { value: 'BLOCKED', label: 'Bloqu√©', color: '#f44336' },
];

const PRIORITIES = [
  { value: 'P0', label: 'P0 - Critique', color: '#f44336' },
  { value: 'P1', label: 'P1 - √âlev√©', color: '#ff9800' },
  { value: 'P2', label: 'P2 - Normal', color: '#2196f3' },
  { value: 'P3', label: 'P3 - Faible', color: '#9e9e9e' },
];

const TASK_TYPES = [
  { value: 'EPIC', label: 'üèîÔ∏è Epic', color: '#9c27b0' },
  { value: 'STORY', label: 'üìù Story', color: '#2196f3' },
  { value: 'TASK', label: '‚úÖ Task', color: '#4caf50' },
  { value: 'BUG', label: 'üêõ Bug', color: '#f44336' },
  { value: 'SPIKE', label: 'üî¨ Spike', color: '#ff9800' },
];

const RISK_LEVELS = [
  { value: 'low', label: 'üü¢ Faible', color: '#4caf50' },
  { value: 'medium', label: 'üü° Moyen', color: '#ff9800' },
  { value: 'high', label: 'üü† √âlev√©', color: '#ff5722' },
  { value: 'critical', label: 'üî¥ Critique', color: '#f44336' },
];

export const TaskFilters: React.FC<TaskFiltersProps> = ({
  onFiltersChange,
  users = [],
  projects = [],
  availableLabels = [],
}) => {
  const [filters, setFilters] = useState<TaskFilterState>(initialFilters);
  const [expanded, setExpanded] = useState(false);
  const [activeFiltersCount, setActiveFiltersCount] = useState(0);

  useEffect(() => {
    // Compter les filtres actifs
    const count = [
      filters.searchTerm ? 1 : 0,
      filters.status.length,
      filters.priority.length,
      filters.type.length,
      filters.assigneeIds.length,
      filters.projectIds.length,
      filters.labels.length,
      filters.isBlocked ? 1 : 0,
      filters.technicalDebt ? 1 : 0,
      filters.dueDateRange.from || filters.dueDateRange.to ? 1 : 0,
      filters.estimationRange.min !== undefined || filters.estimationRange.max !== undefined ? 1 : 0,
      filters.businessValueRange.min !== undefined || filters.businessValueRange.max !== undefined ? 1 : 0,
      filters.riskLevel.length,
      filters.hasAttachments ? 1 : 0,
      filters.hasComments ? 1 : 0,
    ].reduce((a, b) => a + b, 0);

    setActiveFiltersCount(count);
    onFiltersChange(filters);
  }, [filters, onFiltersChange]);

  const handleFilterChange = <K extends keyof TaskFilterState>(
    key: K,
    value: TaskFilterState[K]
  ) => {
    setFilters(prev => ({ ...prev, [key]: value }));
  };

  const clearAllFilters = () => {
    setFilters(initialFilters);
  };

  const clearFilter = (filterType: keyof TaskFilterState) => {
    switch (filterType) {
      case 'searchTerm':
        handleFilterChange('searchTerm', '');
        break;
      case 'status':
        handleFilterChange('status', []);
        break;
      case 'priority':
        handleFilterChange('priority', []);
        break;
      case 'type':
        handleFilterChange('type', []);
        break;
      case 'assigneeIds':
        handleFilterChange('assigneeIds', []);
        break;
      case 'projectIds':
        handleFilterChange('projectIds', []);
        break;
      case 'labels':
        handleFilterChange('labels', []);
        break;
      case 'isBlocked':
        handleFilterChange('isBlocked', undefined);
        break;
      case 'technicalDebt':
        handleFilterChange('technicalDebt', undefined);
        break;
      case 'dueDateRange':
        handleFilterChange('dueDateRange', {});
        break;
      case 'estimationRange':
        handleFilterChange('estimationRange', {});
        break;
      case 'businessValueRange':
        handleFilterChange('businessValueRange', {});
        break;
      case 'riskLevel':
        handleFilterChange('riskLevel', []);
        break;
      case 'hasAttachments':
        handleFilterChange('hasAttachments', undefined);
        break;
      case 'hasComments':
        handleFilterChange('hasComments', undefined);
        break;
    }
  };

  return (
    <Card>
      <CardContent>
        {/* Barre de recherche principale */}
        <Grid container spacing={2} alignItems="center" sx={{ mb: 2 }}>
          <Grid item xs={12} md={8}>
            <TextField
              fullWidth
              placeholder="Rechercher par titre, description, code..."
              value={filters.searchTerm}
              onChange={(e) => handleFilterChange('searchTerm', e.target.value)}
              InputProps={{
                startAdornment: (
                  <InputAdornment position="start">
                    <SearchIcon />
                  </InputAdornment>
                ),
                endAdornment: filters.searchTerm && (
                  <InputAdornment position="end">
                    <Button
                      size="small"
                      onClick={() => handleFilterChange('searchTerm', '')}
                    >
                      <ClearIcon fontSize="small" />
                    </Button>
                  </InputAdornment>
                ),
              }}
            />
          </Grid>
          <Grid item xs={12} md={4}>
            <Box sx={{ display: 'flex', gap: 1, alignItems: 'center', justifyContent: 'flex-end' }}>
              <Badge badgeContent={activeFiltersCount} color="primary">
                <Button
                  variant={expanded ? 'contained' : 'outlined'}
                  startIcon={<FilterIcon />}
                  onClick={() => setExpanded(!expanded)}
                >
                  Filtres
                </Button>
              </Badge>
              {activeFiltersCount > 0 && (
                <Button
                  size="small"
                  variant="text"
                  color="error"
                  startIcon={<ClearIcon />}
                  onClick={clearAllFilters}
                >
                  Tout effacer
                </Button>
              )}
            </Box>
          </Grid>
        </Grid>

        {/* Filtres rapides - toujours visibles */}
        <Box sx={{ display: 'flex', gap: 1, mb: 2, flexWrap: 'wrap' }}>
          {filters.status.map(status => (
            <Chip
              key={status}
              label={TASK_STATUSES.find(s => s.value === status)?.label}
              onDelete={() => handleFilterChange('status', filters.status.filter(s => s !== status))}
              sx={{ bgcolor: TASK_STATUSES.find(s => s.value === status)?.color, color: 'white' }}
            />
          ))}
          {filters.priority.map(priority => (
            <Chip
              key={priority}
              label={priority}
              onDelete={() => handleFilterChange('priority', filters.priority.filter(p => p !== priority))}
              sx={{ bgcolor: PRIORITIES.find(p => p.value === priority)?.color, color: 'white' }}
            />
          ))}
          {filters.assigneeIds.map(assigneeId => {
            const user = users.find(u => u.id === assigneeId);
            return (
              <Chip
                key={assigneeId}
                label={user?.displayName || assigneeId}
                onDelete={() => handleFilterChange('assigneeIds', filters.assigneeIds.filter(id => id !== assigneeId))}
                avatar={<PersonIcon />}
              />
            );
          })}
        </Box>

        {/* Filtres avanc√©s - collapsibles */}
        <Collapse in={expanded}>
          <Grid container spacing={3}>
            {/* Statuts */}
            <Grid item xs={12} md={6}>
              <FormControl fullWidth>
                <InputLabel>Statuts</InputLabel>
                <Select
                  multiple
                  value={filters.status}
                  label="Statuts"
                  onChange={(e) => handleFilterChange('status', e.target.value as TaskStatus[])}
                  renderValue={(selected) => (
                    <Box sx={{ display: 'flex', flexWrap: 'wrap', gap: 0.5 }}>
                      {selected.map((value) => (
                        <Chip key={value} label={TASK_STATUSES.find(s => s.value === value)?.label} size="small" />
                      ))}
                    </Box>
                  )}
                >
                  {TASK_STATUSES.map((status) => (
                    <MenuItem key={status.value} value={status.value}>
                      <Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
                        <Box
                          sx={{
                            width: 12,
                            height: 12,
                            borderRadius: '50%',
                            bgcolor: status.color,
                          }}
                        />
                        {status.label}
                      </Box>
                    </MenuItem>
                  ))}
                </Select>
              </FormControl>
            </Grid>

            {/* Priorit√©s */}
            <Grid item xs={12} md={6}>
              <FormControl fullWidth>
                <InputLabel>Priorit√©s</InputLabel>
                <Select
                  multiple
                  value={filters.priority}
                  label="Priorit√©s"
                  onChange={(e) => handleFilterChange('priority', e.target.value as Priority[])}
                  renderValue={(selected) => (
                    <Box sx={{ display: 'flex', flexWrap: 'wrap', gap: 0.5 }}>
                      {selected.map((value) => (
                        <Chip key={value} label={value} size="small" />
                      ))}
                    </Box>
                  )}
                >
                  {PRIORITIES.map((priority) => (
                    <MenuItem key={priority.value} value={priority.value}>
                      <Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
                        <Box
                          sx={{
                            width: 12,
                            height: 12,
                            borderRadius: '50%',
                            bgcolor: priority.color,
                          }}
                        />
                        {priority.label}
                      </Box>
                    </MenuItem>
                  ))}
                </Select>
              </FormControl>
            </Grid>

            {/* Types */}
            <Grid item xs={12} md={6}>
              <FormControl fullWidth>
                <InputLabel>Types</InputLabel>
                <Select
                  multiple
                  value={filters.type}
                  label="Types"
                  onChange={(e) => handleFilterChange('type', e.target.value as TaskType[])}
                  renderValue={(selected) => (
                    <Box sx={{ display: 'flex', flexWrap: 'wrap', gap: 0.5 }}>
                      {selected.map((value) => (
                        <Chip key={value} label={TASK_TYPES.find(t => t.value === value)?.label} size="small" />
                      ))}
                    </Box>
                  )}
                >
                  {TASK_TYPES.map((type) => (
                    <MenuItem key={type.value} value={type.value}>
                      {type.label}
                    </MenuItem>
                  ))}
                </Select>
              </FormControl>
            </Grid>

            {/* Assign√©s */}
            <Grid item xs={12} md={6}>
              <Autocomplete
                multiple
                options={users}
                getOptionLabel={(option) => option.displayName}
                value={users.filter(user => filters.assigneeIds.includes(user.id))}
                onChange={(_, value) => handleFilterChange('assigneeIds', value.map(u => u.id))}
                renderInput={(params) => (
                  <TextField {...params} label="Assign√©s" />
                )}
                renderTags={(value, getTagProps) =>
                  value.map((option, index) => {
                    const { key, ...tagProps } = getTagProps({ index });
                    return (
                      <Chip
                        key={option.id}
                        label={option.displayName}
                        {...tagProps}
                      />
                    );
                  })
                }
              />
            </Grid>

            {/* Projets */}
            <Grid item xs={12} md={6}>
              <Autocomplete
                multiple
                options={projects}
                getOptionLabel={(option) => `${option.name} (${option.code})`}
                value={projects.filter(project => filters.projectIds.includes(project.id))}
                onChange={(_, value) => handleFilterChange('projectIds', value.map(p => p.id))}
                renderInput={(params) => (
                  <TextField {...params} label="Projets" />
                )}
              />
            </Grid>

            {/* Labels */}
            <Grid item xs={12} md={6}>
              <Autocomplete
                multiple
                freeSolo
                options={availableLabels}
                value={filters.labels}
                onChange={(_, value) => handleFilterChange('labels', value)}
                renderInput={(params) => (
                  <TextField {...params} label="Labels" />
                )}
              />
            </Grid>

            {/* Options bool√©ennes */}
            <Grid item xs={12}>
              <Box sx={{ display: 'flex', gap: 2, flexWrap: 'wrap' }}>
                <FormControlLabel
                  control={
                    <Checkbox
                      checked={filters.isBlocked || false}
                      onChange={(e) => handleFilterChange('isBlocked', e.target.checked ? true : undefined)}
                    />
                  }
                  label="T√¢ches bloqu√©es"
                />
                <FormControlLabel
                  control={
                    <Checkbox
                      checked={filters.technicalDebt || false}
                      onChange={(e) => handleFilterChange('technicalDebt', e.target.checked ? true : undefined)}
                    />
                  }
                  label="Dette technique"
                />
                <FormControlLabel
                  control={
                    <Checkbox
                      checked={filters.hasAttachments || false}
                      onChange={(e) => handleFilterChange('hasAttachments', e.target.checked ? true : undefined)}
                    />
                  }
                  label="Avec pi√®ces jointes"
                />
                <FormControlLabel
                  control={
                    <Checkbox
                      checked={filters.hasComments || false}
                      onChange={(e) => handleFilterChange('hasComments', e.target.checked ? true : undefined)}
                    />
                  }
                  label="Avec commentaires"
                />
              </Box>
            </Grid>

            {/* Plages de dates */}
            <Grid item xs={12}>
              <Accordion>
                <AccordionSummary expandIcon={<ExpandMoreIcon />}>
                  <Typography>Plages de valeurs</Typography>
                </AccordionSummary>
                <AccordionDetails>
                  <Grid container spacing={2}>
                    <Grid item xs={12} md={6}>
                      <Typography variant="body2" gutterBottom>
                        Valeur m√©tier (1-10)
                      </Typography>
                      <Slider
                        value={[
                          filters.businessValueRange.min || 1,
                          filters.businessValueRange.max || 10
                        ]}
                        onChange={(_, value) => {
                          const [min, max] = value as number[];
                          handleFilterChange('businessValueRange', { min, max });
                        }}
                        min={1}
                        max={10}
                        marks
                        step={1}
                        valueLabelDisplay="auto"
                      />
                    </Grid>
                    <Grid item xs={12} md={6}>
                      <Typography variant="body2" gutterBottom>
                        Estimation (heures)
                      </Typography>
                      <Box sx={{ display: 'flex', gap: 1 }}>
                        <TextField
                          size="small"
                          type="number"
                          label="Min"
                          value={filters.estimationRange.min || ''}
                          onChange={(e) => handleFilterChange('estimationRange', {
                            ...filters.estimationRange,
                            min: parseFloat(e.target.value) || undefined
                          })}
                        />
                        <TextField
                          size="small"
                          type="number"
                          label="Max"
                          value={filters.estimationRange.max || ''}
                          onChange={(e) => handleFilterChange('estimationRange', {
                            ...filters.estimationRange,
                            max: parseFloat(e.target.value) || undefined
                          })}
                        />
                      </Box>
                    </Grid>
                  </Grid>
                </AccordionDetails>
              </Accordion>
            </Grid>
          </Grid>
        </Collapse>
      </CardContent>
    </Card>
  );
};